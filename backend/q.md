
# cs 2

1 f
Сколько бит в килобайте?
`1024 * 8 = 8192`

2 f
Из чего состоит процессор?
Процессор состоит из одного или нескольких ядер, кэши различного уровня, шины данных. Ядро состоит из арифметико-логического устройства и устройства управления, регистры.

# linux 9

1 f
Что такое grep?
Поиск в файле, команде
TODO: practice

2 f
Как смотреть сетевые настройки?
```
ip
ip addr show
ip a
ip route show
ir r
ip -s link
```
Заменяет ifconfig, route.
netstat?
TODO: practice

3 f
Как можно выдать доступы пользователю в директорию?
Командами chmod, chgrp, chown.
TODO: practice

4 f
Как можно посмотреть список запущенных процессов?
```
ps aux        # подробный список всех процессов
ps aux | grep <command>
ps aux | grep <username>
ps aux --sort=-%cpu
ps aux --sort=-%mem
top, htop     # динамический список процессов отсортированных по CPU
free          # ram, swap
free -m       # в мегабайтах
free -h       # в человекочитаемом формате
df            # дисковое пространство
df -h /home   # статистика папки
```
a - все процессы, u - расширенная информация об использовании, x - показывает с какого TTY и каким пользователем запускается процесс.
TODO: pratice

5 f
Как убить процесс?
`kill <pid>`

6 f
Как запустить программу в фоне?
Добавить в конец команды символ &

7 f
Что такое демоны?
Демон - это программа, которая запускается в фоновом режиме, ожидая событий и предлагая какие-то службы для их выполнения. 

8 f
Что такое crontab?
Crontab — это текстовый файл, определяющий расписание заданий cron. Есть два типа файлов: общесистемные и файлы отдельных пользователей.

9 f
Как запросить главную страницу гугла через telnet?
```
telnet www.google.com 80
GET / HTTP/1.1
Host: www.google.com
```


# python 63

1 f
Опишите язык Python. f
Высокоуровневый интерпретируемый объектно-ориентированный язык с динамической строгой типизацией.

2 f
Расскажите о динамической типизации в языке Python.
Позволяет изменять тип переменных во время выполнения программы. При этом используется строгая типизация - нужно явное приведение типов.

3 f
Какие типы данных  есть в Python?
Типы данных делятся на две группы: изменяемые и неизменяемые.
* Изменяемые – dict, set, list.
* Неизменяемые – все числовые типы (int, float, complex, ...), bool, tuple, str, NoneType, byte, frozenset

4 f
Какое максимальное число можно положить в тип int?
Изначально 4 байта, если число становится больше, то оно увеличивается ещё на 4 байта.

5 f
Как проверить что одно число типа float равно другому числу float?
Числа типа float хранятся не точно. Нужно использовать вычитание и сравнениее с очень маленьким числом: `if abs(float1-float2) < 0.000001`

6 f
Какими способами можно представить дробные числа в Python?
Типом float, с помощью библиотек decimal (точное хранение десятичных дробей), fractions (точное хранение обыкновенных дробей).

7 f
Какие преимущества и недостатки есть при работе с float?
* Преимущества: скорость вычислений очень быстрая за счет вычислений на процессоре.
* Недостатки: вычисления во float происходят с потерей точности.

8 f
Какие преимущества и недостатки у decimal?
Преимущества: точность вычислений. Недостатки: скорость вычислений.	

9 f
Что происходит при копировании строки?
Создастся новая ссылка на строку.

10 f
Что из себя представляет символ с точки зрения компьютера?
Символ это числовое значение. Конкретный номер определяется кодировкой.	

11 f
Что такое кодировка?
Кодировка это таблица, которая соотносит число и символ.
`Бывают кодировки UTF8, UTF16 и другие. Отличаются они друг от друга размером, который выделяется на хранение одного символа.`

12 f
Какие виды строк ты знаешь?
В Питоне есть один вид строк str, который представляет собой Юникод. Однобайтных строк нет, вместо них есть тип bytes - цепочка байт (задаётся с префиксом b"").
Строки задаются через одинарные, двойные, тройные кавычки. В r'' строках специальные символы (escape sequences) не экранируются.
Также можно задавать строки с префиксом f"".

13 f
Как сделать копию списка?
Поверхностную копию списка можно сделать срезом `b = a[:]`, с помощью метода copy или copy.copy, а глубокое с помощью copy.deepcopy. 

14 f
Какая сложность вставки элемента в список?
append - О(1). insert - О(n).

15 f
Что значит конструкция pass?
Пустой оператор. Используется для заглушек.

16 f
Что такое globals() и locals()?
Функция globals() возвращает словарь, содержащий все глобальные переменные.
locals() возвращает словарь, содержащий аргументы функции и переменные, которым присвоено значение внутри функции.

17 f
Как проверить файл .py на синтаксические ошибки, не запуская его?
Проверка только синтаксических ошибок:
```
python -m py_compile <filename>
python -m compileall -q # -q - output only error messages
```

18 f
Какие есть альтернативы pip?	
* Conda
* poetry
Плюсы:
- Зависимости в .toml файле.
- Фиксация версий в .lock файле.
- Автоматическое управление виртуальными средами без venv.

19 f
Для чего нужен функция id()?
Получение уникального идентификатора (адреса в памяти) объекта.
Выражение is использует функцию id().

20 f
Как сделать python-скрипт исполняемым в различных операционных системах?
PyInstaller - позволяет упаковать скрипт в исполняемый файл для Windows, Linux и macOS.

21 f
Как сделать копию объекта? Как сделать глубокую копию объекта?
Функция/метод copy() создает поверхностную копию объекта. Копия содержит ссылки на те же объекты, что и исходный объект.
Функция copy.deepcopy() создает глубокую копию объекта, рекурсивно копирует объект и все вложенные объекты.

22 f
Как использовать глобальные переменные?
Для использования глобальных переменных достаточно объявить их за пределами функций и классов. В функции использовать global.

23 f
Какие пространства имен существуют в python?
Пространство имен — это совокупность имён и объектов, на которые они ссылаются.
* built-ins: содержит встроенные функции и типы, которые доступны в любой области видимости по умолчанию. `__builtins__`
* Глобальное. globals()
* Локальное. locals()

24 f
Зачем нужен pdb?
pdb - это интерактивный отладчик.
```
import pdb
pdb.set_trace()
# или
python -m pdb <filename>
```

25 f
Как перезагрузить импортированный модуль?
Функция reload() из модуля importlib.

26 f
Расскажи про папку bin?	
В папке bin находятся такие файлы, как:
* Сам интерпретатор Python (например, бинарный файл python или python3).
* Утилита pip (а также pip3, если Python 2 и 3 установлены параллельно).
* Другие инструменты командной строки, установленные через pip install (обычно бинарники и python-скрипты).

27 f
Какие проблемы есть в python?
Глобальная блокировка интерпретатора (GIL). Производительность. Типизация.

28 f
Алгоритмическая сложность сортировки в Python?	
Используется Timsort. Сначала анализирует список, потов выберает наилучший подход. Объединяет сортировку слиянием и сортировку вставками.
В лучшем случае, когда список частично отсортирован - О(n)
В худшем `O(n*log n)`


29 f
С помощью каких инструментов можно выполнить статический анализ кода?
* ruff - линтер и форматирование. Неиспользуемые переменные, ошибки импорта.
* Mypy - проверка типов

30 f
Что будет напечатано в результате выполнения следующего кода?
```
import sys
arr_1 = []
arr_2 = arr_1
print(sys.getrefcount(arr_1))
```
3 - эта величина больше, чем ожидается, потому что в функцию копируется ссылка на объект.
```
getrefcount(object()) # 1
getrefcount([])       # 1
```
Метод ненадёжный. Лучше использовать gc или профилирование памяти.

31 f
Чем фреймворк отличается от библиотеки?
Библиотека представляет собой коллекцию модулей или функций, предназначенных для использования другими приложениями.
Фреймворк представляет собой набор компонентов и задаёт заранее заданную структуру и логику работы.

32 f
Что такое wheels и eggs? В чём разница?
Это форматы пакетов. wheels пришёл на смену eggs и не содержит .pyc файлов, поддерживает сжатие библиотек и упрощает установку требований.

33 f
Как ускорить существующий код python?
Правильные структуры данных, встроенные функции, comprehensions, генераторы, многопоточность/параллелизм/асинхронность, профилирование.

34 f
Что такое pycache? Что такое файлы .pyc?
Когда программа запускается, интерпретатор компилирует ее в байт-код и сохраняет в папке pycache в файлы .pyc. При следующем запуске скрипта байт-код напрямую загружается в память. Python проверяет, есть ли у файла .py уже соответствующий файл .pyc, и, если файл .pyc старше файла .py, компилируется новый кэш.

35 f
Как происходит интерпретация в Python? Чем байт-код отличается от машинного кода?
Когда скрипт запускается в первый раз, интерпретатор компилирует его в байт код (низкоуровневое представление исходного кода) и сохраняет в .pyc. Затем этот байт-код выполняется виртуальной машиной Python (PVM).
Байт код состоит из инструкций (например, LOAD_CONST, CALL_FUNCTION, RETURN_VALUE и т. п.). Можно увидеть в человеко-читаемом виде с помощью модуля dis.
```
def add(a, b):
return a + b
	
import dis
dis.dis(add)
	
2 0 LOAD_FAST 0 (a)
2 LOAD_FAST 1 (b)
4 BINARY_ADD
6 RETURN_VALUE
```

36 f
Python — это императивный или декларативный язык?
Python является императивным языком. Python также поддерживает некоторые функциональные и объектно-ориентированные концепции программирования, однако основной подход в языке является императивным.
Декларативный язык - это язык, который задаёт спецификацию задачи, но не указывает конкретных шагов для ее выполнения. SQL или HTML.

37 f
В чём преимущества массивов NumPy по сравнению со списками python?
NumPy использует более оптимизированную память и имеет более эффективные методы работы с массивами (из-за реализации на C), что делает его подходящим выбором для работы с большими объемами данных и научных вычислений.

38 f
Что такое Cython? Что такое IronPython? Что такое PyPy?
Cython - это язык программирования, нацеленный на увеличение производительности Python-кода. Cython позволяет использовать возможности языка Python и C/C++ для эффективного написания расширений модулей на языке Python. Он позволяет вам писать код на Python, который доступен из C/C++, и наоборот.
IronPython - IronPython предоставляет возможность использовать Python в качестве языка .NET.
PyPy — более быстрая и эффективная альтернатива стандартному интерпретатору CPython.

39 f
Какая есть разница в хранении изменяемых и неизменяемых типов данных?
Для изменяемых типов данных (списки, словари) выделяется дополнительная память под расширение.

40 f
В каких ситуациях возникает исключение NotImplementedError?
Исключение NotImplementedError возникает, когда метод или функция должны быть реализованы в подклассе, но не были реализованы.
```
class MyClass(object):
        def __init__(self):
            self.run()
        def run(self):
            raise NotImplementedError(
                'Определите run в %s.' % (self.__class__.__name__))
    class MySubclass(MyClass):
```

41 f
Что такое monkey patching? Приведите пример использования.
Переопределение метода за пределами объявления класса. Это может быть полезно, когда изменения не могут быть внесены в существующий код.
```
class MyBaseClass:
    def my_method(self):
        print('Hello from MyBaseClass')
	
def monkey_patch():
    def new_method(self):
        print('Hello from new_method')
    MyBaseClass.my_method = new_method
	
monkey_patch()
obj = MyBaseClass()
obj.my_method()  # выведет "Hello from new_method"
```

42 f
Есть ли в Python оператор switch-case?
Начиная с версии Python 3.10, есть оператор match.

43 f
Что нового в последних версиях Python?
Python 3.4: asyncio
Python 3.5: type hints, async/await
Python 3.6: f-strings
Python 3.7:
- Датаклассы
- Словари сохраняют порядок вставки ключей. Гарантируется порядок.
Python 3.9:
- Синаксис `list[int]` при типизации, не нужно импортировать List из typing
Python 3.10:
- match case (аналог switch case), ParamSpec
Python 3.11:
- Ускорение интерпретатора
Python 3.13
- Можно убрать gil, но это замедляет однопоточные сценарии на 10% из-за изменения механизма подсчета ссылок

44 f
В чем разница между NumPy и SciPy?
NumPy используется для операций на векторах, многомерных массивах и матрицах, SciPy используется для решения более сложных задач научных вычислений, таких как оптимизация, интеграция и обработка изображений.

45 f
Что такое интроспекция
Способность программы исследовать тип или свойства объекта во время работы программы: dir, type, isinstance

46 f
Что такое рефлексия
Позволяет коду динамически получать информацию об объектах, а также создавать и изменять их
```
# Без рефлексии
obj.method_name()
# С рефлексией
getattr(obj, method_name)
```

47 f
Что такое lru cache
LRU (least recently used) — это алгоритм, при котором вытесняются значения, которые дольше всего не запрашивались. Соответственно, необходимо хранить время последнего запроса к значению. И как только число закэшированных значений превосходит N необходимо вытеснить из кеша значение, которое дольше всего не запрашивалось.

48 f
Что такое позднее связывание?
Выбор конкретного метода/функции определяется во время выполнения.

49 f
Что такое менеджер пакетов? Какие менеджеры пакетов вы знаете?
Инструмент, который позволяет управлять установкой, обновлением и удалением библиотек и зависимостей в проектах на языке Python.
* pip - это стандартный менеджер пакетов Python. Он позволяет устанавливать пакеты из Python Package Index (PyPI).
* conda - управляет пакетами не только для Python но и для других языков.
* easy_install - использовался до Python 3. Сейчас редко используется.
* poetry - новый менеджер пакетов, предназначенный для замены в некоторой степени pip и virtualenv.

50 f
Как упаковать бинарные зависимости?
pip.
```
pip freeze > requirements.txt
pip install -r requirements.txt
```
poetry
```
poetry new new_project # folder new_project will be created
poetry init # will create .toml in existing folder
# другие команды:
poetry add <package>: Добавить зависимость.
poetry remove <package>: Удалить зависимость.
poetry install: Установить все зависимости.
poetry update: Обновить зависимости.
poetry run python
```

51 f
Как удалить файл в Python?
os.remove()

52 f
Что такое виртуальное окружение?
Механизм, который создаёт изолированную среду для установки и использования пакетов Python. ВО создаётся с помощью модуля venv. После создания, виртуальное окружение нужно активировать. poetry автоматически управляет виртуальными окружениями

53 f
Назовите модули в Python, связанные с файлами
os — как создание, удаление и перемещение файлов.
pathlib — рубота с путями к файлам и директориям.
io — предоставляет классы для работы с текстовыми и бинарными потоками ввода-вывода.
shutil — копирование, перемещение и удаление файлов.
glob - позволяет осуществлять поиск файлов по шаблону
```
import os 
import shutil
from glob import glob
os.getcwd()  # текущий каталог
os.path.exists('sample_data')
os.mkdir('test_dir')  # создаём каталог 'test_dir'
os.listdir('sample_data')
all_csv = list(glob(os.path.join('sample_data', '*.csv')))
print(all_csv)
shutil.copy(
    os.path.join('sample_data', 'README.md'),
    os.path.join('test_dir')
)
```
TODO: practice

54 f
Что делает флаг PYTHONOPTIMIZE/-O?
Игнорирует ассерты, переменную `__debug__` уставнавилвает в False
-OO удаляет docstrings.

55 f
Какие функции из collections и itertools вы используете?
* defaultdict: словать с заданным значением по умолчанию для любого ключа, который еще не был добавлен в словарь.
* Counter: подсчёт количества встречаемых элементов в списке или другом итерируемом объекте. Он возвращает объект, который можно использовать как словарь, где ключами являются элементы, а значения - количество их вхождений.
* namedtuple: можно создать именованный кортеж с заданными полями, что может быть удобно для работы с данными, которые имеют структуру, но не требуют создания класса.
* itertools.chain: позволяет конкатенировать несколько итерируемых объектов в единый итератор.
* itertools.groupby: позволяет группировать элементы итерируемого объекта по заданному ключу.
* itertools.combinations и itertools.permutations: генерируют все различные комбинации или перестановки элементов из заданного множества.


56 f
Что происходит с ячейкой памяти при изменении неизменяемого объекта?
Количество ссылок на объект уменьшается и интерпретатор освободит память, если нет других ссылок на этот же объект.
```
class SomeObject:
    def __del__(self):
        print(f"(Deleting {self=})")
# remove references for such object
```
TODO: practice

57 f
Через какой модуль можно указывать типы в Python?	
Через typing, но с каждой версией Python всё больше возможностей встраивается в базовый синтаксис языка без импортирования typing
Callable, Optional, Any, TypeVar, ParamSpec
TODO: practice

58 f
Что такое comprehension (генератор списков, множеств, словарей)?
Это способ создания нового списка с использованием краткой записи. Работает быстрее циклов, потому что обработка выполняется на уровне С.

59 f
Отличие type() и isinstance()?
Функция type() возвращает точный тип объекта. Она не учитывает наследование.
Функция isinstance() проверяет, является ли объект экземпляром указанного класса или его родителя. Учитывает наследование.

60 f
Какие есть виды типизации и какая используется в Python?
Статическая/динамическая (контроль типов при компиляции/во время выполнения).
Строгая/не строгая (явно/не явно приводятся типы).
Явная/не явная (переменной задаётся тип изначально/переменной можно присвоить любое значение).

61 f
Перечисли основные плюсы и минусы Python	
Плюсы:
* Простой и читаемый синтаксис
* Большое сообщество разработчиков и библиотек
* Динамическая типизация (типы переменных определяются во время выполнения), т.к. добавляет гибкость коду
* Объектно-ориентированный язык
* Высокоуровневая абстракция для работы с данными (множества, словари, списки)
Минусы:
* GIL
* Интерпретируемый язык - ниже производительность, чем у компилируемых
* Нет полноценной статической типизации, может привести к неочевидным ошибкам.

62 f
Чем интерпретируемые языки отличаются от компилируемых?	
Компилируемые языки (C, C++, Rust, Go и т.п.):
* Процесс компиляции. Исходный код преобразуется в машинный код (инструкции для конкретного процессора). Результат — это исполняемый файл.
* Производительность как правило, выше, так как итоговый код исполняется непосредственно «железом».
* Портируемость. Нужно перекомпилировать программу под каждую целевую платформу.
* Отладка и разработка может быть сложнее, т.к. изменения в коде требуют новой компиляции. Зато компилятор может находить типовые ошибки ещё на этапе сборки, до запуска программы.
Интерпретируемые языки (Python, Ruby, JavaScript и т.п.):
* Процесс интерпретации. Исходный код считывается и исполняется «на лету» (иногда со стадией байткода, как в Python, но всё равно есть «виртуальная машина»). Нет явного шага компиляции в машинный код перед запуском (хотя за кулисами может быть JIT-компиляция (just-in-time)).
* Производительность обычно ниже, чем у скомпилированных языков: каждая строчка/блок кода проходит через интерпретатор.
* Портируемость. Достаточно, чтобы на целевой системе был установлен соответствующий интерпретатор.
* Проще и быстрее править и тестировать код: изменения вступают в силу сразу (нет полного цикла компиляции). Ошибки часто обнаруживаются уже во время выполнения, а не до запуска.

63 f
Расскажи про обобщённые (TypeVar/Generic) типы?	
TypeVar - класс из модуля typing, который используется для создания обобщенных (generic) типов. Он позволяет функциям и классам работать с различными типами данных, сохраняя при этом аннотацию и проверку типов.
Пример для функции:
```
from typing import TypeVar
	
T = TypeVar('T')
	
def get_first_element(elements: list[T]) -> T:
return elements[0]
```
Пример для класса:
```
from typing import TypeVar, Generic
	
T = TypeVar('T')
	
class Container(Generic[T]):
	def __init__(self, content: T):
		self.content = content
	
	def get_content(self) -> T:
		return self.content
	
int_container = Container[int](content=123)
str_container = Container[str](content="Hello")
```
Можно ограничить типы, например
```
Number = TypeVar('Number', int, float)
```
TODO: practice


# memory 7

1 f
Произошла утечка памяти в рабочем приложении. Как бы вы начали отладку?
tracemalloc, objgraph. objgraph позволяет посмотреть на что ссылается объект и какие объекты ссылаются на него. cProfile, memory_profiler - для поиска медленных мест.
```
python -m cProfile -s time script.py 10001
	
python -m memory_profiler script.py
	
from memory_profiler import profile
@profile   
def my_func():
    # pss
	
import objgraph
my_list = [1, 2, 3]
objgraph.show_refs([my_list], filename='my_list.png')
	
import tracemalloc 
tracemalloc.start() 
snapshot = tracemalloc.take_snapshot() 
top_stats = snapshot.statistics('lineno') 
```
TODO: practice

2 f
Как происходит увеличение ссылки в Python. Атомарное ли это действие?
Думаю что нет, наверное, сначала берётся значение, потом увеличивается.. Я бы посмотрел байт-код для простого примера.

3 f
Какие типы утечек данных ты знаешь?
Есть два основных типа – большие объекты (огромная строка) - ищем с помощью отладчика, tracemalloc, memory_profiler и много маленьких объектов (бесконечный связный список) - ищем с помощью objgraph.
Ещё один тип утечек - сторонние расширения на C.

4 f
Почему всякий раз, когда python завершает работу, не освобождается вся память?
Память освобождается, так как выделением памяти занимается операционная система. Возможно в вопросе имеется ввиду удаление объектов. 

5 f
Что такое интернирование объектов? Почему это есть в python?
Оптимизация, при которой две неизменяемые переменные ссылаются на один и тот же объект в памяти.

6 f
Как реализован сборщик мусора в Python?
Сборщик мусора в Питоне состоит из двух частей – подсчет ссылок и generational garbage collector (GC) - модуль gc.
Каждый объект в Python содержит дополнительное поле (счетчик ссылок), в котором хранится количество ссылок на него. Как только кто-то ссылается на объект, это поле увеличивается на единицу. В Python, алгоритм подсчета ссылок является фундаментальным и не может отключен.
GC - это сборщик мусора и используется для обнаружения и удаления циклических ссылок. GC срабатывает периодически и каждый запуск сборщика создает микропаузы в работе кода. Python использует механизм, называемый «обнаружение циклов».
Сборщик мусора разделяет все объекты на 3 поколения (генерации). Новые объекты попадают в первое поколение. Если новый объект выживает после процесса сборки мусора, то он перемещается в следующее поколение. Чем выше поколение, тем реже оно сканируется на мусор.
gc можно запускать вручную.
gc срабатывает автоматически при достижения порогового значения. Для каждого поколения своё.
Алгоритм сборщика:
GC итерирует каждый объект из выбранных поколений и временно удаляет все ссылки от отдельно взятого объекта (все ссылки на которые этот объект ссылается). После полного прохода все объекты, у которых счетчик ссылок меньше двух считаются недоступными и могут быть удалены.

7 f
Как происходит выделение памяти
Большие блоки памяти - Арены (256кб).
Арены содержат пулы (4кб). Каждый пул содержит блоки одинакового размера (8 байт, 16 байт...). При выделении памяти под объект Питон ищет подходящий пул.

# sequence 22

1 f
Что такое последовательность в Питон?
Объект, который реализует `__getitem__()` (доступ к элементам с использованием индексов) и `__len__()` - реализует протокол последовательностей. В более полном варианте нужны ещё методы: `__contains__` (поддержка in), `__iter__`, `__reversed__`.
Встроенные последовательности: str, list, tuple, range и bytes.

2 f
Какие операции поддерживают большинство последовательностей
доступ по индексу, срез, len, in, конкатенация, min, max, sum.

3 f
Как проверить, что один кортеж содержит все элементы другого кортежа?
all(). Передать ей выражение генератора списков, которое проверяет наличие каждого элемента из второго кортежа в первом кортеже.
```
contains_all = all(elem in first_tuple for elem in second_tuple)
```
Можно использовать issubset(), то есть проверить, является ли одно множество подмножеством другого:
```
first_tuple = (1, 2, 3, 4, 5)
some_list = [2, 4, 5]
contains_all = set(some_list).issubset(set(first_tuple))
```
TODO: practice

4 f
Как кодировать и декодировать строки
Кодировать – перевести Юникод в байтовую строку. Вызвать метод .encode() у строки.
Декодировать – восстановить строку из цепочки байт. Вызвать метод .decode() у объекта bytes.
В обоих случаях явно передавать кодировку, иначе будет использована та, что определена в системе по умолчанию. Быть готовым поймать исключения UnicodeEncodeError, UnicodeDecodeError.

5 f
Что такое диапазон range.
Отдельный тип, который создаёт неизменяемую последовательность чисел. Задаётся началом, концом и шагом.

6 f
Каким образом выделяется память в списке?
Список - это массив указателей на объекты. В памяти хранятся два блока. Один фиксированный - информация о списке, второй хранит ссылки на элементы.
При создании списка, памяти выделяется немного больше чем нужно (на 1/8). Это позволяет достичь времени O(1) для вставки элементов в конец списка. 
Хранится размер списка и размер доступного места.
При достижения размера списка выделяется новая память под список. Чем больше элементов в списке, тем больше будет выделено дополнительной памяти для роста.
Размер можно посмотреть с помощью sys.getsizeof().

7 f
Что из list и tuple будет занимать больше памяти при больших данных?
Больше будет занимать list. Кортежи неизменяемы - выделяется фиксированный объём памяти.
Кортежи хранят элементы внутри структуры. Списки хранят указатели на элементы.
Посмотреть сколько памяти занимает список можно с помощью метода `__sizeof__` или sys.getsizeof() (результаты разные). getsizeof добавляет накладные расходы сборщика мусора.
TODO: practice

8 f
Можно ли изменить список лежащий внутри кортежа?
Да, можно.

9 f
Можно ли использовать кортеж со списком внутри как ключ словаря?
Нет, нельзя. Ключом словаря может быть только хешируемый объект.					

10 f
Чем кортежи отличаются от списков?
Кортеж – неизменяемый объект, список – изменяемый. Кортеж может быть ключом словаря. Кортежи более эффективными производительности и памяти. Пустой кортеж работает как синглтон.
Обе коллекции представлены массивом указателей на структуру PyObject.
TODO: Замерить время создания очень больших списков кортежей.

11 f
Что такое срез?
Срез это частичная или полная поверхностная копия списка, строки или кортежа. Задается так: `a[start:stop:step]`

12 f
Можно ли положить изменяемый объект во множество?
Нет, нельзя. Во множестве может быть только хешируемый объект. Можно положить изменяемый объект пользовательского класса, так как по умолчанию он хэшуриуется по id.

13 f
Что будет происходить со множеством при росте его элементов?
Чем больше элементов во множестве тем больше количество возникающих коллизий. Из-за этого эффективность поиска элемента во множестве сильно падает вплоть до О(n)

14 f
Может ли быть индекс списка отрицательным?
Да.

15 f
Какая сложность поиска элемента во множестве?
Если без коллизий, то О(1). Если с коллизиями, то вплоть до О(N)

16 f
Какая сложность удаления/вставки элемента из множества?
О(1). Если есть коллизии то сложность увеличивается вплоть до О(n)

17 f
Может ли кортеж содержать изменяемые объекты?
Да, может. В таком случае он теряет свойство хешируемости.



22 f
Как сравниваются последовательности
Сравниваются последовательности одного типа. Сравнения происходят в лексикографическом порядке.


# sets 18

1 f
Как dict и set реализованы внутри? Какова сложность получения элемента? Сколько памяти потребляет каждая структура?
Dict и Set реализованы в виде хэш-таблицы. Сложность операций добавления, удаления и поиска элементов в Set и Dict составляет O(1) в наилучшем случае и O(n) в худшем случае.


2 f
Какая характеристика определяет неизменяемые типы данных?
Хешируемость. Чтобы тип данных (класс) стал хешируемым ему нужно определить два магических метода – `__hash__` и `__eq__`. В противном случае он сравнивается по id. Все стандартные неизменяемые объекты хешируемые.

3 f
Как создать словарь с ключами - множествами?
Использовать frozenset, так как set являются неизменяемым типом.
```
my_dict = {
    frozenset({1, 2, 3}): "значение1",
    frozenset({4, 5}): "значение2",
    frozenset({6}): "значение3"
}
```


4 f
Для чего обычно применяются множества?
Проверка на вхождение в множество и удаление повторяющихся значений, объединение, пересечение, разница и симметрическая разница.

5 f
Что такое отображение
Отображение (mapping) – это объект-контейнер, который поддерживает произвольный доступ к элементам по ключам и описывает все методы, описанные в абстрактном базовом классе collections.abc.Mapping: `__getitem__`, `__contains__`, keys(), values(), items().
К отображениям относятся классы dict, collections.defaultdict, collections.OrderedDict и collections.Counter.

6 f
Какие нюансы есть в использовании чисел как ключей
Числовые ключи в словарях подчиняются правилам сравнения чисел. Таким образом, int(1) и float(1.0) считаются одинаковым ключом. Однако из-за того, что значения типа float сохраняются приближенно, не рекомендуется использовать их в качестве ключей. Это же касается и True.

7 f
Что возвращает метод items
Объекты, возвращаемые методами items(), keys() и values() это объекты представления словаря. Они предоставляют динамическое представление элементов словаря, то есть изменения данного словаря автоматически отображаются и на этих объектах. Мы можем проитерировать, получить длину и проверить находится ли ключ в словаре
TODO: practice

8 f
Что может быть ключом словаря?
Ключом словаря может быть любой хешируемый неизменяемый объект: число, строка, кортеж.

9 f
Есть два списка – ключи и значения. Как составить из них словарь.
`dict(zip(keys, vals))`

10 f
Что такое множество?
Неупорядоченная коллекция уникальных элементов. set (изменяемое множество), frozenset (неизменяемое множество).

11 f
Что такое коллизия?
Коллизия это когда хеш-код двух значений совпадает. Из-за этого в хеш-таблице по одному и тому же коду ищуются разные значения и растет сложность поиска вплоть до О(n).

12 f
Где будет быстрее поиск, а где перебор и почему: dict, list, set, tuple
Поиск будет быстрее в dict и set, потому что это хэш-таблицы, доступ к элементу которых выполняется за O(1). Для list и tuple поиск будет выполняться в среднем за O(n).
Исключение работает только для очень маленьких списков длиной до 5 элементов. В этом случае интерпретатору будет быстрей пробежаться по списку, чем считать хеш.

13 f
Как отсортировать список словарей по определенному полю
Метод списка .sort() и встроенная функция sorted() принимают параметр key.

14 f
Как выглядит хэш-код
Число.

15 f
Что такое хэш-таблица
Структура данных, которая позволяет хранить пары "ключ-значение" и обеспечивает быстрый доступ к значению по ключу.
В хэш-таблице каждому элементу соотвествует ячейка, содержащая два поля: ссылку на ключ и ссылку на значение элемента.
Внутри словарь (dict) использует разреженный массив для хранения данных.
Хэш-таблица использует хэш-функцию для преобразования ключа в индекс массива, где хранится значение.

16 f
Как работает хэш-таблица?
* Хэширование ключа: Хэш-функция принимает ключ и возвращает уникальное числовое значение (хэш).
* Определение индекса: Хэш используется для определения индекса в массиве, где будет храниться значение. Индекс обычно вычисляется как остаток от деления хэша на размер массива.
* Если найденная ячейка пуста, возбуждается исключение KeyError. 
* Разрешение коллизий: Если два ключа имеют одинаковый хэш, используется метод разрешения коллизий, например, цепочки или открытая адресация.
* При удалении элемента из хеш-таблицы python не очищает ячейку памяти, так как при использовании метода открытой адресации нельзя будет обнаружить элементы, которые идут после удалённого при коллизии. Элементу добавляется специальный маркер, а python перехеширует всю таблицу, когда маркеров становится много.

17 f
Как устроен в Python метод разрешения коллизий?
В Python используется метод открытой адресации.
Есть следующие методы:
Цепочки (Chaining): Каждый индекс массива содержит связанный список всех элементов, имеющих одинаковый хэш. Это позволяет хранить несколько элементов в одном индексе.
Открытая адресация (Open Addressing): При коллизии ищется следующий свободный индекс в массиве. Этот метод включает несколько стратегий, таких как линейное пробирование, квадратичное пробирование и двойное хэширование.
* Линейное пробирование — это метод открытой адресации, при котором при коллизии мы просто переходим к следующему индексу в массиве. Если и там есть элемент, переходим к следующему и так далее, пока не найдем свободный индекс.
* Квадратичное пробирование использует квадратичную функцию для определения следующего индекса при коллизии. Это помогает уменьшить кластеризацию элементов.

18 f
Как выглядит деструктор в Python?
Метод `__del__` вызывается сборщиком мусора, когда на объект больше нет ссылок. Точный момент вызова деструктора зависит от реализации сборщика мусора.



# functions 18

1 f
Что такое `*args` и `**kwargs` в определении функции?
Специальные параметры в Python, которые позволяют передавать переменное количество неименованных/именнованных аргументов. `*args` собирает все "лишние" аргументы в кортеж, а `**kwargs` - в словарь. Если в функцию не передано никаких параметров, переменные будут соответственно равны пустому кортежу и пустому словарю.

2 f
Почему пустой список нельзя использовать как аргумент по умолчанию?
Пустой список создаётся единожды при определении функции а не при каждом вызове.

3 f
Можно ли передавать функцию в качестве аргумента другой функции?
Да.
Функция - объект первого порядка.
Можно присваивать, передавать в функцию, удалять.

4 f
Можно ли в лямбде использовать pass или raise
Нет, при загрузке модуля выскочит исключение SyntaxError. В теле лямбды может быть только выражение. pass и raise являются операторами.

5 f
Как передаются значения аргументов в функцию или метод
По ссылке. При вызове функции в её области видимости создаётся имя, которое связывается с существующим объектом. Но, стоит учитывать, что в Python есть изменяемые и неизменяемые типы.

6 f
Что такое каррирование
Карринг — это преобразование функции от многих аргументов в набор функций, каждая из которых является функцией от одного аргумента. Мы можем передать часть аргументов в функцию и получить обратно функцию, ожидающую остальные аргументы.

7 f
Что такое docstring?
Cтрока документации, которая описывает, что делает функция, метод, класс Python. Данная строка располагается в начале определения объекта и используется для генерации документации.

8 f
Что такое рекурсия?
Рекурсия это когда функция вызывает саму себя.

9 f
Что такое лямбда-функция? Какое у неё назначение?
Однострочкая анонимная функция. Лямбда-функции в основном используются в качестве аргументов функций высшего порядка, которые принимают другие функции в качестве аргументов.
Примеры: квадраты числа, чётные числа, использование с sorted (упорядочить по длине строки), map, filter...
Нельзя использовать pass, exception.
TODO: practice

10 f
Что такое замыкание?
Синтаксически это выглядит как функция, находящаяся целиком в теле другой функции. При этом вложенная внутренняя функция содержит ссылки на локальные переменные внешней функции. Каждый раз при выполнении внешней функции происходит создание нового экземпляра внутренней функции, с новыми ссылками на переменные внешней.

11 f
Для чего нужен модуль operator?
Модуль operator содержит функции, которые соответствуют стандартным операторам. Может быть полезен если в функцию нужно передать оператор как аргумент. Также есть смысл использовать с функциями высшего порядка.

12 f
Что такое функции высшего порядка?
Функции высшего порядка - это функции, которые могут принимать другие функции в качестве аргументов или возвращать функции в качестве результата.
Примеры: map(), filter() и reduce(). 

13 f
Что такое объект первого класса
Объектами первого класса (англ. first-class object, first-class entity, first-class citizen) в контексте конкретного языка программирования называются сущности, которые могут быть переданы как параметр, возвращены из функции, присвоены переменной. В Python, как и в функциональных языках, функции являются объектами первого класса.

14 f
Что такое функциональное программирование
Функциональное программирование – раздел дискретной математики и парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании). Противопоставляется парадигме императивного программирования, которая описывает процесс вычислений как последовательное изменение состояний (в значении, подобном таковому в теории автоматов)

15 f
Как у Python с поддержкой функционального программирования
Python частично поддерживает парадигму функционального программирования и позволяет писать код в функциональном стиле. Кроме того, в нём присутствуют определённые возможности, характерные для функциональных языков или впервые появившиеся в функциональных языках (списковые включения, лямбда-функции, функции высшего порядка и т.д.).

16 f
Опишите функции map, reduce, filter модуля functools
Функция map применяет функцию к каждому элементу последовательности. Возвращает итератор.
Функция filter применяет заданную функцию-предикат к каждому элементу итерируемого объекта и возвращает итератор с элементами, для которых функция вернула True. 
Функция reduce (в Python 3 находится в модуле functools) выполняет функцию на каждой паре элементов итерируемого объекта, возвращает редуцированное значение.
TODO: practice

17 f
Какие вы знаете функции из модуля functools
Модуль functools содержит большое количество стандартных функций высшего порядка. Среди них особенно полезны:
* reduce
* Декоратор total_ordering. Достаточно реализовать `__eq__` и один из оставшихся методов сравнения, а остальные сгенерируются автоматически.
* lru_cache (и другие кэши) – декоратор, который кеширует значения функций, которые не меняют свой результат при неизменных аргументах; полезен для кеширования данных, мемоизации (сохранения результатов для возврата без вычисления функции) значений рекурсивных функций (например, такого типа, как функция вычисления n-го числа Фибоначчи) и т.д.;
* partial – частичное применение функции (вызов функции с меньшим количеством аргументов, чем она ожидает, и получение функции, которая принимает оставшиеся параметры).
* wraps для декораторов.
TODO: practice

18 f
Какие функции знаете из модуля itertools
Модуль itertools содержит функции для работы с итераторами и создания итераторов. Некоторые из его функций:
* count(start, step) - итератор начинает с start и до бесконечности через шаг.
* product – декартово произведение итераторов (для избегания вложенных циклов for);
* permutations – генерация перестановок;
* combinations – генерация сочетаний;
* combinations_with_replacement – генерация размещений;
* chain – соединение нескольких итераторов в один;
* takewhile – получение значений последовательности, пока значение функции-предиката для её элементов истинно;
* dropwhile – получение значений последовательности начиная с элемента, для которого значение функции-предиката перестанет быть истинно.
TODO: practice


# iterators 18

1 f
Что такое контейнер?
Контейнер – это тип данных, который инкапсулирует в себе значения других типов. Списки, кортежи, множества, словари и т.д. являются контейнерами.

2 f
Что такое итерабельный (итерируемый) объект?
 Это любой объект который можно "пройти" по элементам, то есть итерировать. В классе нужно реализовать метод `__iter__()`. Функция iter() вызывает метод `__iter__`.  В цикле for эта функция вызывается неявно.
 `__getitem__()` - legacy.


3 f
Что такое итератор?
Объект, который знает, как "пройтись" по итерируемому объекту, предоставляя доступ к его элементам по одному
Поддерживает протокол итерации - реализует два метода `__iter__()` и `__next__()`.
Метод `__next__()` (можно вызывать функцией next()) возвращает следующий элемент последовательности, если элементов больше нет, то выбрасывает исключение `StopIteration` 
Метод `__iter__()` возвращает сам объект итератора. Вызывается в начале цикла `for` или при явном вызове `iter()`. Любой итератор является итерабельным объектом и может быть использован почти везде, где принимаются итерабельные объекты. Но не все итерируемые объеты являются итераторами. Например: списки или строки являются итерируемыми, но не являются итераторами, т.к не имеют `__next__()`.
TODO: practice

4 f
Что такое генератор?
Языковая конструкция, которую можно реализовать двумя способами: как функция с ключевым словом yield или как генераторное выражение. В результате получаем объект-генератор типа types.GeneratorType.
Генераторы вычисляют значения по мере необходимости, что делает их особенно полезными для работы с большими или бесконечными последовательностями данных. Они не загружают все данные в память, а генерируют их по одному элементу.
Любой генератор является итератором.
```
def gen():  
    yield 1  
    yield 2  
[print(f""First Iteration {i}"") for i in gen()]  
[print(f""Second Iteration {i}"") for i in gen()]
	
# Канонический пример:
def fib():  
    a, b = 0, 1  
    while True:  
        yield a  
        a,b = b, a + b  
	
f = fib()  
for _ in range(10):  
    print(next(f))
```
TODO: practice

5 f
Чем генератор отличается от итератора?
Итератор используется для обхода коллекции до тех пор, пока все элементы не будут перебраны, а генератор используется для создания последовательности значений.
```
example_i = [i for i in range(3)] # Iterator: [0, 1, 2]  
example_g = (i for i in range(3)) # Generator: <generator object <genexpr> at 0x10099bd60>
```

6 f
Что такое генераторная функция?
Генераторная функция - функция, в теле которой встречается ключевое слово yield. Будучи вызвана, такая функция возвращает объект-генератор (generator object).

7 f
Для чего используется ключевое слово yield?
yield останавливает генератор и возвращает текущее значение. После следующего вызова `__next__()` генератор продолжает своё выполнение.

8 f
Как перевернуть генератор?
По сути это невозможно. Можно получить список с обратным порядком элементов. Нам в любом случае нужно будет пройти по элементам генератора.
```
my_list = [1, 2, 3, 4, 5]
my_generator = (x**2 for x in my_list)
reversed(list(my_generator)) # reversed возвращает итератор
```

9 f
В чем отличие `[x for x in y]` от `(x for x in y)`?
Первое выражение возвращает список (списковое включение), второе – генератор.

10 f
Что особенного в генераторе?
Генератор использует внутреннее состояние для вычисления очередного элемента. Нельзя вернуться к предыдущему элементу.

11 f
Как объявить генератор?
Использовать синтаксис (x for x in seq) или использовать оператор yield в теле функции вместо return.

12 f
Как получить из генератора список?
Передать его в конструктор списка: `list(x for x in some_seq)`. Важно, что после этого по генератору уже нельзя будет итерироваться.

13 f
Что такое подгенератор (subgenerator)?
Генератор внутри генератора. Конструкция yield from.
```
# Generator that yields numbers[1 to n]
def generate_numbers(n):
    for num in range(1, n + 1):
        yield num
	
# Generator for finding and yielding a given number's divisors
def find_divisors(num):
    for i in range(1, num + 1):
        if num % i == 0:
            yield i
	
# Main generator employs 'yield from' to directly pass on divisors of each number
def numbers_and_divisors(n):
    for num in generate_numbers(n):
        print(f"Divisors of {num}: ", end="")
        # 'yield from' is used here to seamlessly yield values from the subgenerator
        yield from find_divisors(num)
        print() 
	
# Utilizing the setup with n=10
for divisor in numbers_and_divisors(10):  
    print(divisor, end=" ")
```
TODO: practice

14 f
Можно ли извлечь элемент генератора по индексу?
Нет, будет ошибка. Генератор не поддерживает метод `__getitem__`.

15 f
Что возвращает итерация по словарю?
Ключ. Порядок следования ключей гарантируется (с версии 3.7).

16 f
Как итерировать словарь по парам ключ-значение?
Метод словаря .items() возвращает генератор кортежей (key, value).

17 f
Что будет напечатано в результате выполнения следующего кода?
```
def f_g():
    yield 43
    return 66
	
print(f_g())
```
Результат выполнения кода будет объект генератора (generator object). Когда мы вызываем функцию с yield, то это создает генератор, который возвращает объект-итератор. Так как print(f_g()) вызывает только генератор, а не запускает его выполнение, то мы получим объект-итератор в качестве результата, а не значение, возвращенное посредством yield или return.
TODO: practice

18 f
Какие методы есть у генераторов?
Эти методы вызываются у объекта-генератора
`send(value)` – отправляет значение в функцию-генератор. Аргумент value становится значением текущего yield-выражения. Если send() используется для запуска генератора, то единственным допустимым значением является None, так как ещё не было выполнено ни одно yield-выражение, которому можно присвоить это значение.
`throw(type[, value[, traceback]])` – выбрасывает исключение типа type в месте, где был приостановлен генератор, и возвращает следующее значение генератора (или выбрасывает StopIteration). Если генератор не обрабатывает данное исключение (или выбрасывает другое исключение), то оно выбрасывается в месте вызова.
`close()` – останавливает генератор. Можно использовать на бесконечных последовательностях. Вызывает исключение StopIteration.
TODO: practice

# modules 5

1 f
В чём разница между пакетами и модулями?
Модуль - это файл, содержащий код.
Пакет - это директория, содержащая один или несколько модулей, а также специальный файл `__init__.py`, который выполняется при импорте пакета. Он может содержать код, который инициализирует переменные, функции и классы, и становится доступным для использования внутри модулей, находящихся внутри этого пакета.

2 f
Как можно получить имя модуля?
Название модуля доступно в его глобальной переменной `__name__`. Если модуль не импортирован, а запущен как скрипт, то `__name__` устанавливается в значение `__main__`.

3 f
Что такое модульное программирование?
Организация программы как совокупности небольших независимых блоков, называемых модулями.

4 f
Как Python ищет модули при импорте?
При импортировании модулей интерпретатор Python ищет их в директориях, список которых доступен в виде переменной path встроенного модуля sys. По умолчанию sys.path состоит из директории с запускаемым скриптом, содержимого переменной окружения PYTHONPATH и стандартного расположения модулей.
TODO: practice

5 f
Что вы можете сказать о конструкции import package.item?
При использовании оператора from package import item, item может быть пакетом, модулем или любым именем, описанным в пакете. При использовании оператора import package.item, item должен быть модулем или пакетом.

# exceptions 13

1 f
Что такое обработка исключений (exception handling)?
Механизм, который позволяет как-то реагировать на ошибки в программе. 
try...except...else...finally
raise

2 f
Для чего могут применять конструкцию try finally без except?
Если в блоке try произойдет ошибка, то блок finally все-равно будет выполнен и внутри него можно будет сделать "cleanup", например.

3 f
Как правильно по-разному обрабатывать исключения?
Блоки except обрабатываются сверху вниз и управление передаётся не больше, чем одному обработчику. Поэтому при необходимости по-разному обрабатывать исключения, находящиеся в иерархии наследования, сначала нужно указывать обработчики менее общих исключений, а затем – более общих. Также именно поэтому  просто except может быть только последним (иначе SyntaxError).

4 f
Что будет если ошибку не обработает блок except?
Исключение будет перехвачено ближайшим внешним блоков try/except, в котором есть соответствующий обработчик. Если же программа не перехватывает исключение вообще, то интерпретатор завершает выполнение программы и выводит информацию об исключении в стандартный поток ошибок sys.stderr. Из этого правила есть два исключения:
* Если исключение возникло в деструкторе объекта, выполнение программы не завершается, а в стандартный поток ошибок выводится предупреждение “Exception ignored” с информацией об исключении.
* При возникновении исключения SystemExit происходит только завершение программы без вывода информации об исключении на экран.


5 f
Что делать если нужно перехватить исключение, выполнить действия и опять возбудить это же исключение?
raise без параметров выбрасывает то же самое исключение ещё раз.

6 f
Что такое сцепление исключений?
Сцепление исключений позволяет сохранить исходную причину исключения при дополнительной обработке ошибки.
В Python при возбуждении исключения в блоке except, старое исключение сохраняется в атрибуте данных `__context__` и если новое исключение не обработано, то будет выведена информация о том, что новое исключение возникло при обработке старого («During handling of the above exception, another exception occurred:»).
```
try:
    try:
        1 / 0  # Деление на ноль
    except ZeroDivisionError as e:
        raise ValueError("Произошла ошибка значения") from None
except ValueError as ve:
    print(f"Поймано исключение: {ve}")
    print(f"Контекст: {ve.__context__}")
    
Поймано исключение: Произошла ошибка значения
Контекст: division by zero
	
try:
    try:
        1 / 0  # Деление на ноль
    except ZeroDivisionError as e:
        raise ValueError("Произошла ошибка значения") from e
except ValueError as ve:
    print(f"Поймано исключение: {ve}")
    print(f"Причина: {ve.__cause__}")
	
Поймано исключение: Произошла ошибка значения
Причина: division by zero
	
try:
    try:
        1 / 0  # Деление на ноль
    except ZeroDivisionError as e:
        raise ValueError("Произошла ошибка значения") from None
except ValueError as ve:
    print(f"Поймано исключение: {ve}")
    print(f"Причина: {ve.__cause__}")
	
Поймано исключение: Произошла ошибка значения
Причина: None
```

7 f
Зачем нужен блок else?
Блок else выполняется, если в процессе выполнения блока try не возникло исключений. Выполняется перед finally.

8 f
Что можно передать в конструктор исключения?
Любые неименованные аргументы. Чаще всего, строка - сообщение об ошибке.
Метод `__str__` по умолчанию вызывает `str(self.args)`.

9 f
Какие есть классы исключений?
Базовые:
```
BaseException – базовый класс для всех исключений.
Exception – класс-наследник BaseException, базовый класс для для всех стандартных исключений, которые не указывают на обязательное завершение программы, и всех пользовательских исключений.
```
Некоторые из конкретных стандартных исключений:
```
AssertionError – провал условия в операторе assert.
AttributeError – ошибка обращения к атрибуту.
ImportError – ошибка импортирования модуля или имени из модуля.
IndexError – неверный индекс последовательности (например, списка).
KeyboardInterrupt – завершение программы путём нажатия Ctrl+C в консоли.
RuntimeError – общая ошибка времени выполнения, которая не входит ни в одну из категорий.
SyntaxError – ошибка синтаксиса.
IndentationError – подкласс SyntaxError – неверный отступ.
SystemExit – исключение, которое генерируется функцией sys.exit(). Служит для завершения работы программы.
TypeError – ошибка несоответствия типов данных.
ZeroDivisionError – деление на ноль.
```

10 f
В каких случаях можно обработать SyntaxError?
* ошибка синтаксиса в импортируемом модуле;
* ошибка синтаксиса в коде, который представляется строкой и передаётся функции eval или exec. eval  возвращает результат.

11 f
Можно ли создавать собственные исключения?
Можно. Они должны быть наследниками класса Exception. Принято называть исключения так, что имя их класса заканчивается словом Error.

12 f
Для чего нужны предупреждения (warnings) и как создать собственное?
Предупреждения обычно выводятся в ситуациях, когда что-то не так, но программа может продолжать работу - пользователя следует уведомить о чём-либо. Базовым классом для предупреждений является Warning, который наследуется от Exception. Базовым классом для пользовательских предупреждений является UserWarning.
В модуле warnings собраны функции для работы с предупреждениями. Основной является функция warn.

13 f
Когда будет выполнена ветка else в конструкции try…except…else...finally?
Только в том случае, если исключения не было возбуждено в блоке try.

# decorators 6

1 f
Что такое декоратор? Как написать собственный?
Механизм, который позволяет расширять функции, не меняя внутренней реализации самой функции. Декораторы могут использоваться для добавления логирования, проверки аутентификации, тайминга выполнения.
Декоратор в широком смысле - паттерн проектирования, когда один объект изменяет поведение другого. В Питоне декоратор, как правило, это функция A, которая принимает функцию B и возвращает функцию C. При этом функция C задействует в себе функцию B.

2 f
Зачем нужен wraps?
wraps - декоратор из модуля functools. Он назначает функции-врапперу те же поля `__name__`, `__module__`, `__doc__`, что и у исходной функции, которую вы декорируете. Это нужно для того, чтобы функция-враппер в стектрейсах выглядела как декорируемая функция.

3 f
Что может быть декоратором. К чему может быть применен декоратор?
Декоратором может быть любой вызываемый объект: функция, лямбда, класс, экземпляр класса. В последнем случае определите метод `__call__`. Применять декоратор можно к любому объекту. Чаще всего к функциям, методам и классам. Декорирование встречается настолько часто, что под него выделен особый оператор @.
```
def auth_only(view):
    ...
@auth_only
def dashboard(request):
    ...
	
# без @
def auth_only(view):
    ...
def dashboard(request):
    ...
dashboard = auth_only(dashboard)
```

4 f
Что будет, если декоратор не возвращает ничего?
Если в теле функции нет оператора return, вызов вернет None. Результат декоратора замещает декорируемый объект. При попытке вызвать функцию после декорирования получим ошибку "NoneType is not callable".

5 f
В чем отличие @foobar от @foobar()
Первое -- обычное декорирование функцией foobar.
Второй случай -- параметризованный декоратор или фабрика декораторов.

6 f
Что такое фабрика декораторов?
Параметризированный декоратор.

# io 19

1 f
Что такое файловый объект?
Это объект, предоставляющий файл-ориентированный API (методы read(), write() и т.д.) для доступа к ресурсу. Работает как с реальными файлами так и потоками ввода/вывода и сокетами.

2 f
Какие есть виды файловых объектов?
Текстовые файлы (text files), обычные бинарные файлы (raw binary files) и буферизированные бинарные файлы (buffered binary files). Разные виды потоков представляются соответствующими классами модуля io.

3 f
В чём отличие текстовых и бинарных файлов?
Текстовые файлы записывают и считывают данные типа str и автоматически выполняют преобразования кодировок и концов строк. Бинарные файлы записывают и считывают данные типов bytes и bytearray и не производят никаких манипуляций с данными: всё записывается и считывается в таком же виде, как и сохраняется.

4 f
Как пользоваться функцией open
`open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)`.
buffering – использовать ли буферизацию: отрицательное число – стандартное значение для данного вида файлового объекта, 0 – отключить буферизацию, 1 – построчная буферизация (для текстовых файлов), другое значение – включить буферизацию и задать соответствующий размер буфера.
mode может начинаться с символов «r» (чтение), «w» (запись, очищает файл, если уже существует), «x» (исключительное создание, неуспешно, если файл уже существует), «a» (добавление, запись в конец файла). Также параметр mode может иметь вторую букву для определения типа файла: «t» для текстового (по умолчанию) и «b» для бинарного. Также можно добавить символ «+» для открытия в режиме чтения и записи одновременно. Порядок последних двух символов не имеет значения: «rb+» и «r+b» задают один и тот же режим.

5 f
Для чего необходимо закрывать файлы?
При использовании буферизированного вывода данные, которые записываются в файл, не попадают в него сразу, а записываются в буфер. Содержимое буфера записывается в файл при его заполнении или вызове методов flush() или close(). Кроме того, если файл открыт для записи, он будет заблокирован для открытия для записи другими процессами до момента закрытия.

6 f
Что делают методы tell и seek?
Метод tell() возвращает текущую позицию считывания/записи в файле. Метод seek(offset, whence) устанавливает её.

7 f
Что делают StringIO и BytesIO?
Это потоки для считывания/записи в строки или байтовые строки в памяти. Они позволяют использовать строки/байтовые строки в качестве текстовых и бинарных файлов.

8 f
Являются ли файловые объекты контекстными менеджерами?
Да

9 f
Что такое сериализация?
Процесс сохранения объектов в двоичном или текстовом виде для хранения/передачи/восстановления. Обратный процесс - десериализация.

10 f
json.dumps / json.dump , json.loads / json.load?
Функция dumps модуля json сохраняет JSON-представление объекта в строку. Функция dump – в текстовый файл. Функция loads модуля json загружает объект из строки. Функция load – из текстового файла.

# oop 42

1 f
Что такое SOLID? Как расшифровывается?
SOLID обозначает пять основных принципов применимых к ООП.
* S - Single Responsibility Principle - принцип единственной ответственности. Каждый класс должен решать лишь одну задачу. Пример: UserManager сохраняет и проверяет пользовательские данные. Разделяем на UserRepository, UserValidator, UserManager. При обновлении пользователя UserManager, использует UserValidator для валидации, а потом сохраняет пользователя с помощью UserRepository.
* O - Open closed Principle - принцип открытости-закрытости. Классы должны быть открыты для расширения, но закрыты для изменения. Пример: Есть калькулятор скидки, в нём зашит код, тип скидки вычисляется внутри кода, в зависимости от аргумента (тип пользователя, тип скидки). Создаём абстрактный класс для скидки с методом apply_discount и создаём несколько типов скидок, которые высчитывают скидки по-разному. В калькулятор скидок передаём нужный тип скидок и вызываем apply_discount.
* L - Liskov substitution Principle - принцип подстановки Барбары Лисков. Должна быть возможность вместо базового класса подставить любой его подтип (класс-наследник), при этом работа программы не должна измениться. наследуемый класс должен дополнять, а не замещать поведение родительского класса. Пример: В качестве базового класса берём прямоугольник, подтипы: квадрат, окружность. Считаем площадь. Правильно будет в качестве базового класса взять Shape и от него унаследовать квадрат, прямоугольник, окружность, каждый со своим расчётом площади.
* I -  Interface Segregation Principle - принцип разделения интерфейсов. Не нужно заставлять класс реализовывать интерфейс, которым он не пользуется. Пример: Есть OrderRepository c абстрактными методами save и rollback. Два наследника: SQLOrderRepository, NoSQLOrderRepository. У второго может не быть роллбэка. Лучше разделить так: OrderRepository с методом save, от него наследуется TransactionalRepository с методом rollback. SQLOrderRepository наследуем от TransactionalRepository, а NoSQLOrderRepositiory от OrderRepository.
* D - Dependency Inversion Principle - принцип инверсии зависимостей. Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те и те должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Пример: Есть NotificationService и есть SMSService. NotificationService хранит sms_service и вызывает sms_service_send_sms. Нужно убрать детали. Создаём класс Notifier с абстрактным методом send_notification. SMSService наследуем от него. Можно создать EmailService. В NotificationService передаём Notifier и при отправке уведомления вызываем notifier.send_notification.
TODO: hard

2 f
Расскажи про принципы ООП?
* Инкапсуляция — это упаковка данных и функций в одну единицу, называемую объектом.
* Наследование — механизм языка, который позволяет описывать новый класс на основе существующего. Это помогает сократить повторение кода.
* Полиморфизм - позволяет использовать одно и то же имя метода для выполнения различных задач в зависимости от объекта, который его вызывает
* Абстракция — детали реализации методов и свойств объектов скрыты от пользователя. 

3 f
Что такое Миксин? Для чего используются? 
паттерн, когда в цепочку наследования добавляется небольшой класс-помощник. Добавляет новую функциональность в классы, не изменяя их иерархии наследования.
В Django:  FormMIxin, LoginRequiredMixin.

4 f
Как обратиться к родительскому методам и атрибутам классу из дочернего?
С помощью функции `super()`. Она позволяет вызывать методы родительского класса без явного указания имени этого класса.	
```
class B(A):
	def __init__(self):
		super().__init__()
```

5 f
Что такое абстрактный класс?
Абстрактный класс - это класс, который является классом-шаблоном для других классов. Он позволяет определить методы, которые должны быть реализованы подклассами. Используется модуль abc. abc.ABC - базовый класс, @abc.abstractmethod
В Python нет встроенной поддержки интерфейсов.

6 f
Что такое абстрактный метод?
Это метод, который объявлен в абстрактном классе, но не имеет реализации. Он служит шаблоном для метода, который должен быть реализован в подклассах.	

7 f
Для чего нужен метод `__init__()`?
Используется для инициализации нового объекта после его создания.

8 f
В чем разница между методами `__new__()` и `__init__()`?
Метод `__new__()` является статическим, и используется для создания нового экземпляра класса. Вызывается перед `__init__()`.
`__init__()` инициализирует уже созданный объект.
```
class TestClass:
    def __new__(cls, *args, **kwargs):
        instance = super().__new__(cls)
        return instance
```

9 f
Что такое и чем отличается old-style от new-style classes?
Классы нового стиля используются в 3.х, в 2.х при наследовании от object.
* Убирают отличия встроенных типов от пользовательских.
* Множественное наследование имеет иной порядок поиска.

10 f
Что такое утиная типизация?
Использование объекта определяется его набором методов и свойств. `__iter__`, `__next__` - итератор, `__hash__`, `__eq__` - хэшируемый объект.

11 f
Что такое контекстный менеджер? Для чего используется? Как написать свой?
Контекстные менеджеры используются для обращения с ресурсами, которые должны быть корректно открыты и закрыты: файлы, сетевые соединения, базы данных.
Контекстный менеджер задаётся с помощью with. При входе вызывается метод `__enter__()`. Затем выполняется код в блоке with. При завершении блока with вызывается метод `__exit__()`. При исключении в блок `__exit__` будет передана тройка значений (exc_class, exc_instance, traceback).
```
# Пример реализации своего контекстного менеджера на основе класса:
class Printable:
    def __enter__(self):
        print('enter')
	
    def __exit__(self, type, value, traceback):
        print('exit')
	
from contextlib import contextmanager
@contextmanager
def printable():
    print('enter')
    try:
      yield
    finally:
      print('exit')
```
TODO: practice

12 f
Прокомментировать выражение `object() == object()`
Всегда ложь, поскольку по умолчанию объекты сравниваются по полю id (адрес в памяти), если только не переопределен метод `__eq__`.

13 f
Что такое self?
Экземпляр класса. Передается как первый аргумент в методы класса и позволяет работать с атрибутами и методами.

14 f
Как получить доступ к переменной с двумя подчеркиваниями?
Интерпретатор автоматически назначает таким переменным имя вида `object._ClassName__Attribute`. Этот механизм называется name mangling.

15 f
Для чего в классе используется атрибут `__slots__`?
Атрибут `__slots__` в классе Python используется для оптимизации памяти и ускорения работы с объектами класса. Он жёстко фиксирует набор полей класса.
Уменьшает потребление памяти, потому что оно изменяет способ хранения атрибутов объекта - атрибуты хранятся в массиве.
```
class Person:
    __slots__ = ['name', 'age']
    def __init__(self, name, age):
        self.name = name
        self.age = age
```
У объекта пропадает поле `__dict__`  Можно добавить его в `__slots__` вручную.
TODO: practice, example

16 f
В чем смысл параметров `_value`, `__value`?
Поле класса с одним лидирующим подчеркиванием говорит о том, что параметр используется только внутри класса. При этом он доступен для обращения извне. Это ограничение доступа только на уровне соглашения.
Поля с двойным подчеркиванием доступны внутри класса, но недоступны извне.

17 f
Что такое MRO (Method Resolution Order)? Как это работает?
MRO - это порядок разрешения методов. Алгоритм, по которому следует искать метод в случае, если у класса два и более родителей.
* Перечисление всех классов с обходом в глубину (DFLR). Класс включается в результат поиска столько раз, сколько он встречается при обходе.
* Удаление всех дубликатов в списке кроме последнего (крайнего справа).
Доступ к списку наследования доступен через аттрибут `__mro__` или метод mro() класса.
Пример наследования в неромбовидных иерархаических деревьях:
```
class D:          attr = 3      #  D:3   E:2
class B(D):       pass          #   |     |
class E:          attr = 2      #   B    C:1
class C(E):       attr = 1      #    /   /
class A(B, C):    pass          #      A
X = A()                         #      |
print(X.attr)                   #      X
# DFLR = [X, A, B, D, C, E]
# MRO = [X, A, B, D, C, E, object]
# 3
```
Пример наследования в ромбовидных иерархаических деревьях:
```
class D:          attr = 3      #  D:3   D:3
class B(D):       pass          #   |     |
class C(D):       attr = 1      #   B    C:1
class A(B, C):    pass          #    /   /
X = A()                         #      A
print(X.attr)                   #      |
                                #      X
# DFLR = [X, A, B, D, C, D]
# MRO = [X, A, B, C, D, object] (сохраняет только последний дубликат D)
# Выводит строку "1"
A.mro()
A.__mro__
```

18 f
Что такое Diamond problem?
Как при ромбовидном наследовании определить метод какого класса должен быть вызван

19 f
Что такое датаклассы?
Способ упрощенного создания классов для хранения данных. Ближайший аналог - NamedTuple из collections.
Датаклассы позволяют сосредоточиться только на описании полей, а остальные методы генерируются автоматически.
Основные особенности:
* Автоматическое создание методов: `__init__`, `__repr__`, `__eq__`.
* Аннотации типов: Поля датакласса требуют аннотаций типов.
* Модификации через параметры: Можно легко настраивать поля, указывая параметры, такие как default, default_factory, и другие.
```
@dataclass(order=True, frozen=True)
class Product:
   name: str
   price: float = 0.0
   description: str = field(default="No description available")
   tags: List[str] = field(default_factory=list)
```

20 f
`__call__` и когда использовать?
Позволяет объекту вести себя как функция. Делает объект вызываевым.
Декоратор класса.

21 f
Как получить список атрибутов объекта?
Функция dir возвращает список полей объекта. Поле `__dict__` содержит словарь атрибутов вида {поле -> значение}.

22 f
Python полностью поддерживает ООП?
Да. В Python все объекты в явном виде являются экземплярами классов, и даже типы данных, такие как список или словарь, являются классами со своими методами и атрибутами.

23 f
Что такое @classmethod, @staticmethod?
@classmethod используется для создания методов, которые будут работать с классом в целом. Первый параметр - класс. Часто используется для создания фабричных методов. Вызывать можно и через класс и через объект.
@staticmethod используется для создания статических методов. Вызывать можно и через класс и через объект.


24 f
Что такое метаклассы и в каких случаях их следует использовать?
Метаклассы - это классы, которые определяют поведение других классов. Наследуются напрямую от type. Нужно реализовать `__new__`
Основное применение метаклассов это создание API. Типичный пример — Django ORM.
```
class Person(models.Model):
  name = models.CharField(max_length=30)
  age = models.IntegerField()
guy = Person(name='bob', age='35')
print guy.age
```
вы получите не IntegerField, а int, причём значение может быть получено прямо из базы данных.
Это возможно, потому что models.Model определяет `__metaclass__`, который сотворит некую магию и превратит класс Person, который мы только что определили простым выражением в сложную привязку к базе данных.
Django использует метаклассы в адмике, моделях, формах. виджетах.
TODO: hard

25 f
Отличие композиции от агрегации?
При композиции объект создаётся внутри класса. При агрегации объект передаётся извне. Композиция - более сильная связь. 

26 f
Как сделать декоратор из класса?
Необходимо определить класс с методом `__init__` и методом `__call__`

27 f
Как создать класс без слова class?
```
MyClass = type('MyClass', (), {'x': 42, 'foo': lambda self: self.x})
name = 'ExampleClass'
bases = (object,)
attrs = {'__init__': lambda self: print('Hello from __init__')}
ExampleClass = type(name, bases, attrs)
example = ExampleClass()
```
TODO: practice

28 f
Что такое магические методы (dunder-методы)?
Это специальные методы, которые начинаются и заканчиваются двойным подчеркиванием. Они позволяют определить, как объекты этого класса будут вести себя в различных контекстах, например, при использовании операторов Python. Их вызывают встроенные функции или синтаксические конструкции.

29 f
Что такое метод?
Это функции, определенные внутри класса, которые могут быть вызваны экземпляром или самим классом.

30 f
Что такое @property (аксессоры (getters), мутаторы (setters))?
Декоратор, который позволяет создать метод класса, который может быть использован как атрибут объекта.
```
@property
def value(self):
	print(self._name, 'GET', self._value)
	return self._value
	
@value.setter
def value(self, value):
	print(self._name, 'SET', self._value)
	self._value = value
```

31 f
Что такое дескрипторы? Есть ли разница между дескриптором и декоратором?
Это механизм, который позволяет управлять доступом к атрибутам. Протокол дескрипторов включает в себя `__get__`, `__set__`, `__delete__`.
Разница между дескриптором и декоратором заключается в том, что дескрипторы используются для определения поведения атрибутов объекта, в то время как декораторы используются для изменения поведения функций. Однако, декораторы могут использоваться для реализации протоколов дескрипторов.
Например, декоратор @property можно использовать для создания дескриптора доступа к атрибутам.

32 f
Что такое KISS?
Keep It Stupid Simple - простой код. Под простотой главным образом имеется в виду отказ от использования хитроумных приемов и ненужного усложнения.
Пример нарушения: использование побитового оператора (right shift >> 1) для деления целых чисел на 2. Последнее, безусловно, более эффективно, чем обычное (/2), но при этом очень сильно снижается понятность кода.

33 f
Что такое DRY?
Принцип Don’t Repeat Yourself напоминает нам, что каждое повторяемое поведение в коде следует выделять в отдельную функцию для возможности многократного использования.

34 f
Что такое YAGNI?
You Aren’t Gonna Need It говорит о том, что нежелательно оставлять в продакшене «точки расширения». Такие точки расширения вносят ненужную сложность и увеличивают размер вашей кодовой базы.

35 f
Что такое SLAP?
Принцип Single Level of Abstraction Principle (Принцип одного уровня абстракций) означает, что функции должны иметь один уровень абстракции. Скажем, функция, читающая input, не должна также обрабатывать полученные данные. Для этого она должна задействовать отдельную функцию, находящуюся на другом, более низком уровне абстракции.

36 f
Что такое code cohesion & code coupling?
Связанность модулей (coupling), характеризует степень независимости модулей. 
Связность (cohesion) - насколько модуль является простым с точки зрения его использования.

37 f
Что такое type. Как работает поиск метакласса при создании объекта?
type это метакласс, который Питон внутренне использует для создания всех классов. Когда вы пишете:
```
class Foo(Bar):
  pass
```
Питон делает следующее:
* Есть ли у класса Foo атрибут `__metaclass__`?
* Если да, создаёт в памяти объект-класс с именем Foo, используя то, что указано в `__metaclass__`.
* Если Питон не находит `__metaclass__`, он ищет `__metaclass__` в родительском классе Bar и попробует сделать то же самое.
* И если он не может найти вообще ни одного `__metaclass__`, он использует type для создания объекта-класса.

38 f
Поддерживает ли python множественное наследование?
Да, Python поддерживает множественное наследование. Это означает, что класс может наследовать функциональность от нескольких предков, путем указания их имен в скобках при определении класса. 

39 f
В чем отличие интерфейса от абстрактного класса?	
В абстрактном классе может быть реализована часть методов, которые наследуют и используют дочерние классы, а в интерфейсе методы не реализуются.

40 f
Разница между type и object?
Все классы наследуют от object. 
```
isinstance(anyObject, object) # True
```
type - это метакласс класса object.

41 f
Как получить атрибут класса по его строковому названию?
getattr(object, attrname)

42 f
В чём разница между `__getattr__()` и `__getattribute__()`?
`__getattribute__` используется, чтобы получить атрибут экземпляра. Испольуется при обращении через точку или вызывается функция getattr().
`__getattr__` вызывается в случае если атрибут не был найден - можно будет вернуть значение по умолчанию или вызвать исключение AttributeError.


# concurrency 36

1 f
Какие задачи хорошо параллелятся, какие плохо? 
Хорошо параллелятся задачи, которые порождают долгий IO. Когда тред упирается в ожидание сокета или диска, интерпретатор бросает этот тред и стартует следующий, соответствуенно, нет простоя из-за ожидания.
Плохо параллелятся задачи связанные с вычислениями.

2 f
Нужно посчитать 100 уравнений. Делать это в тредах или нет?
Нет. Интерпретатор будет тратить время на переключение тредов. 
Лучше:
* вынести в отдельные процессы
* Celery
* подключать как C-библиотеки

3 f
Что такое GIL? Зачем он нужен, как он работает?
GIL (Global Interpreter Lock) — это механизм, который позволяет только одному потоку одновременно выполнять байт-код Python. GIL гарантирует каждому потоку эксклюзивный доступ к переменным интерпретатора.
Преимущество: быстрые однопоточные приложения.
Если держим GIL gc работает, но gc может захватывать GIL, чтобы обеспечить потокобезопасность.

4 f
Что такое корутины?
Специальные функции, которые могут останавливать своё выполнение и возобновлять его позже.
Их выполнение приостанавливается с помощью выражения await, а возобновляется после того, как это выражение разрешится.
```
import asyncio  
async def my_coroutine():  
    print(""Начало корутины"")  
    await asyncio.sleep(1)  
    print(""Корутина возобновлена"")
    
asyncio.run(my_coroutine()) # запуск корутины через event loop
```
Расширенные возможности генераторов в Python (yield и yield from, отправка значений в генераторы) используются для реализации корутин. 

5 f
Чем отличается future от корутины?
Корутина — это функция, которая может выполняться асинхронно и ждать других операций, не блокируя поток.
`Future` — это низкоуровневый объект - результат асинхронной операции, который будет доступен в будущем.

6 f
Что такое event loop? Как он работает внутри?
Отвечает за выполнение асинхронных задач. Постоянно проверяет, есть ли задачи, готовые к выполнению (например, завершившиеся операции ввода-вывода), и передаёт управление этим задачам.
*  Инициализация - asyncio.run()
* Добавление задач в очередь.
* Обработка событий:
  1. Ожидание задач: Event loop проверяет, есть ли задачи, готовые к выполнению
  2. Выполнение задач: Event loop берёт готовую задачу из очереди и передаёт ей управление.
  3. Возвращение к ожиданию: После выполнения текущих задач event loop снова переходит в режим ожидания или проверки новых событий.


7 f
Как запустить чтение файла в асинхронном коде?
В отдельном потоке или aiofiles - асинхронный аналог стандартного чтения файла.
```
import asyncio
import aiofiles
async def read_file_async(f_path):
 async with aiofiles.open(f_path, mode='r') as f:
  content = await f.read()
asyncio.run(read_file_async('example.txt'))
```
TODO: practice

8 f
Что такое потокобезопасность?
В потокобезопасной программе данные, к которым обращаются несколько потоков, защищены от конкуретного доступа. Реализуется с помощью элементов синхронизации ( мьютексы, семафоры и др)
```
from threading import Thread, Lock  
counter = 0  
lock = Lock()  
def increment():  
    global counter  
    for _ in range(1_000_000):  
        with lock:  
            counter += 1
    
t1 = Thread(target=increment)  
t2 = Thread(target=increment)  
t1.start()  
t2.start()  
t1.join()  
t2.join()  
print(counter)
```
TODO: practice

9 f
Какие ты знаешь способы синхронизации потоков?	
* Lock - только один поток может владеть блокировкой в любой момент времени.
* RLock - это рекурсивная блокировка, которая позволяет одному и тому же потоку захватывать блокировку несколько раз, без риска блокировки самого себя.
* Semaphore ограничивает количество потоков, которые могут одновременно выполнять определённую операцию
* Event позволяет одному потоку сигнализировать другим потокам о том, что они могут продолжить выполнение
```
event = Event()  
def wait_for_event():  
    print(""Waiting Event"")  
    event.wait()  
    print(""Received Event"")  
def set_event():  
    print(""Set Event"")  
    event.set()
```
* Condition позволяет потокам ждать определённого условия и продолжать выполнение, когда это условие становится истинным.
```
condition = Condition()  
def wait_for_condition():  
    with condition:  
        print(""Waiting Condition"")  
        condition.wait()  
        print(""Condition was True"")  
def notify_condition():  
    time.sleep(1)  
    with condition:  
        print(""Notifying"")  
        condition.notify()
 ```
* Barrier — это синхронизатор, который позволяет нескольким потокам достичь одной точки выполнения, прежде чем всем им будет разрешено продолжить работу.
TODO: practice

10 f
Расскажи подробно про то когда нужно применять потоки?
Для задач связанных с операциями ввода/вывода. I/O-bound задач (сетевые запросы, файловые операции, доступ к БД).
Библиотеки на C. NumPy, Pandas.
Legacy-код, где нет асинхронности.
Параллельного выполнения задач с общим состоянием (с осторожностью).

11 f
Расскажи подробно про то когда нужно применять процессы?
Процессы следует использовать когда:
* Нужно задействовать ядра процессоров ( CPU интенсивные задачи)
* Нужно обойти ограничения GIL в CPython
* Нужна изоляция задач для повышения безопасности и отказоустойчивости

12 f
Для каких задач лучше всего подходит асинхронность?
Интенсивный ввод-вывод, где требуется высокая производительность и масштабируемость.
Микросервисы и API, 

13 f
В какой момент потоки переключаются между собой? Можем ли мы управлять переключением потоков?
* Вытесняющая многозадачность.  Операционная система использует таймер, который периодически прерывает выполнение текущего потока и передаёт управление другому потоку. Этот процесс называется вытесняющей многозадачностью.
 ```
 def task1():  
     while True:  
         x = 0  
         for i in range(100000):  
             x += i  
         print(""Task 1 is running"")
	
 def task2():  
     while True:  
         y = 0  
         for i in range(100000):  
             y += i  
         print(""Task 2 is running"")
 ```
* Блокирующие операции. Поток может добровольно уступить управление, когда он выполняет блокирующую операцию, такую как ввод-вывод
 ```
 def read_file():  
     print(""Opening file..."")  
     with open(""example.txt"", ""r"") as file:  
         print(""Reading file..."")  
         content = file.read()  # Блокирующая операция: чтение данных из файла  
     print(""File read complete."")  
     print(content) 
	
 def other_task():  
     print(""Starting other task..."")  
     for i in range(5):  
         print(f""Other task iteration {i}"")
```
* Явная передача управления. Поток может сам явно уступить управление другим потокам, используя time.sleep(0) или threading.Event().wait(timeout=0)
 ```
def task1():  
    for i in range(1_000):  
         print(f""Task 1 - Iteration {i}"")  
         time.sleep(0)  # Явное уступление управления другим потокам
	
def task2():  
    for i in range(1_000):  
         print(f""Task 2 - Iteration {i}"")  
         time.sleep(0)  # Явное уступление управления другим потокам"
```
TODO: practice

14 f
Что такое гринлеты. Общее понятие. Примеры реализаций
Greenlet - легковесные треды внутри виртуальной машины. Операционная система не видит их. Модуль greenlet.

15 f
Где быстрее происходит переключение: в процессах или потоках?
В потоках, так как они находятся в одном адресном пространстве - меньше информации нужно сохранить и загрузить.

16 f
Кто управляет переключением потоков?
Операционная система

17 f
Кто управляет переключением корутин в асинхронном коде?
Цикл событий. Передача управления следующей сопрограмме происходит вручную, при явном вызове конструкции await.

18 f
Что такое синхронный код?
Это код, который выполняется последовательно и блокирует выполнение других задач до его завершения.

19 f
Что такое асинхронный код? Приведите пример.
Выполнение нескольких задач одновременно в рамках одного потока.
Примером использования асинхронного кода является библиотека asyncio в Python.
```
import asyncio
async def hello():
    await asyncio.sleep(1)
    print("Hello")
    
async def world():
    await asyncio.sleep(2)
    print("World")
    
async def main():
    await asyncio.gather(hello(), world())
    
if __name__ == '__main__':
    asyncio.run(main())
```

20 f
Чем отличаются многопоточное и многопроцессорное приложение?
В многопроцессорных приложениях каждый процесс имеет свой собственный набор ресурсов: память, файлы, сетевые соединения. Модуль multiprocessing.
В многопоточных приложениях несколько потоков выполняются в рамках одного процесса, используя общие ресурсы: память, переменные, модули. Модуль threading.

21 f
Как в питоне реализуется многопоточность. Какими модулями
Многопоточность достигается модулем Threading. Это нативные Posix-треды (исполняются ОС, а не виртуальной машиной).
Также есть concurrent.futures.ThreadPoolExecutor: высокоуровневый интерфейс

22 f
Работали ли Вы с asyncio? В чём его особенность?
Библиотека для написания асинхронного кода. Использует однопоточную модель с кооперативной многозадачностью. asyncio подходит для io-bound задач.

23 f
Что такое async/await, для чего они нужны и как их использовать?
Нужны чтобы не блокировать поток выполнения на время ожидания какого-нибудь асинхронного события.
async/await превращает функцию в корутину.
```
import asyncio
import aiohttp
urls = ['http://www.google.com', 'http://www.yandex.ru', 'http://www.python.org']
	
async def call_url(url):
    async with aiohttp.ClientSession() as session:
        print('Starting {}'.format(url))
        async with session.get(url) as response:
            data = await response.text()
            print('{}: {} bytes: {}'.format(url, len(data), data))
            return data
	
# запуск в асинхронной функции
tasks = [call_url(url) for url in urls]
results = await asyncio.gather(*tasks)
```
TODO: practice

24 f
Что такое task в asyncio?
Task запускает корутину в цикле событий.
Задача является подклассом Future.

25 f
Что такое race condition(состояние гонки)?
Ситуация, когда два потока пытаются одновременно изменить одни и те же данные.

26 f
Что такое планировщик потоков?
Компонент операционной системы, который управляет распределением процессорного времени между потоками. 

27 f 
Что такое потоковое голодание?
Ситуация, когда поток не получает процессорного времени. Распределением времени между потоками занимается планировщик потоков, которым нельзя управлять.

28 f
Как под капотом работает асинхронное чтение файла(aiofiles)?
В aiofiles при чтении файла создается отдельный поток, в котором производится блокирующий системный вызов read()/write().
Чтение файла (сист. вызов read()) блокирует другие одновременные чтения файла. Аналогично запись в файл write() блокирует другие записи.  При этом чтение во время записи может извлечь незавершенную запись в файл.

29 f
Как работает aiohttp на уровне OC?
aiohttp  позволяет асинхронно выполнять запросы и получать ответы в неблокирующем режиме. 
Алгоритм:
1. Aiohttp создаёт (или использует из пула) неблокирующий сокет, регистрирует его в Event Loop
2. Пока ответ ожидается, Event Loop выполняет другие корутины
3. Когда ответ поступает на сокет, ОС обновляет его состояние.
4. Механизм мультиплексирования (epoll - linux, kqueue - mac, iocp - windows) обнаруживает, что сокет готов к чтению, и отправляет сигнал для event loop об этом
5. Event Loop возобновляет выполнение соответствующей корутины, которая делает системный вызов recv() для чтения инфы из сокета
* Механизм мультиплексирования - метод, позволяющий эффективно обрабатывать множество соединений или потоков данных одновременно на уровне ОС. Он постоянно следит за состоянием каждого сокета и уведомляет сервер, если на каком-то из сокетов появились данные.
* recv() - функция на языке Си, которая встроена в ОС для чтения данных из сокета, позволяет асинхронно выполнять запросы и получать ответы в неблокирующем режиме.
TODO: посмотреть про epoll., epoll.poll.kqueue

30 f
Python как решается проблема общего хранилища в асинхронном коде?
asyncio.Lock — позволяет блокировать доступ к общему ресурсу, пока одна задача его использует. Другие задачи будут ждать, пока блокировка не будет снята.
Если общее хранилище представляет собой очередь данных, можно использовать asyncio.Queue, который является потокобезопасным и позволяет безопасно обмениваться данными между задачами.
Если нужно ограничить количество одновременных доступов к ресурсу, можно использовать asyncio.BoundedSemaphore.
asyncio.Event или asyncio.Condition Эти примитивы могут быть полезны для координации задач и управления доступом к общим ресурсам.

31 f
Можно ли из синхронной функции вызвать асинхронную и наоборот?
Вызов асинхронной функции из синхронной. 
* Если у нас есть асинхронная функция, можем вызвать её из синхронного кода с помощью asyncio.run(). Это создаст евент луп. Нельзя использовать внутри другого евент лупа.
Вызов синхронной функции из асинхронной.
```
    loop = asyncio.get_running_loop()
    result = await loop.run_in_executor(None, sync_function)
```
Позволяет выполнить синхронный код в отдельном потоке

32 f
Отличие gather от wait?
gather - запускает несколько асинхронных задач параллельно и ожидает их завершения. Возвращает список результатов всех задач. Отменяет все задачи при ошибке.
wait. Позволяет указать условия завершения (например, ожидание первой завершенной задачи). Возвращает два множества: done (завершенные задачи) и pending (незавершенные задачи). Не возвращает результаты задач напрямую — нужно извлекать их вручную.
Условия завершения wait: по умолчанию ждёт завершения всех задач. Может завершить ожидание, как только завершится первая, или когда одна задача завершится ошибкой.
TODO: example

33 f
Есть массив с 10к ссылок. Каждая ссылка на папочку, там аватарка. Кейс: пройтись по ссылкам, выгрузить аватаркию for занимает 30 минут. Как ускорить?
Используем asyncio с aiohttp. Можем поставить семафор (например, 100) для ограничения одновременного количества запросов. Когда задача начинает выполняться, она захватывает семафор, когда завершается - освобождает.
Также можем добавить прокси, если есть ограничение на количество запросов с одного ip.

34 f
Пример работы семафора?
Ограничение количества одновременно выкачиваемых ссылок, чтобы не столкнуться с ддосом.
```
import asyncio
	
async def task(semaphore, task_id):
    async with semaphore:  # Захватываем семафор
        await asyncio.sleep(1)  # Имитация долгой операции
	
async def main():
    semaphore = asyncio.Semaphore(2)
    tasks = [task(semaphore, i) for i in range(5)]
    await asyncio.gather(*tasks)  # Запускаем все задачи
    
asyncio.run(main())
```

35 f
Вызвать 100 корутин, чтобы они одновременно выполнялись
```
import asyncio
	
async def my_coroutine(task_id):
    print(f"Задача {task_id} началась")
    await asyncio.sleep(1)  # Имитация долгой операции
    print(f"Задача {task_id} завершилась")
	
async def main():
    tasks = [my_coroutine(i) for i in range(100)]
    
    # Запускаем все корутины одновременно
    await asyncio.gather(*tasks)
	
# Запуск асинхронного кода
asyncio.run(main())
```

36 f
В чём преимущества асинхронности над многопоточностью в питон?
В переключения между потоками есть накладные расходы. В асинхронности управление на уровне приложения. epoll (мониторинг файловых дескрипторов) гораздо дешевле переключения потоков.
1000 задач для евент лупа - не проблема. Для потоков - это капец.



# testing 13

1 f
Какие виды тестирования ты знаешь? Какие из них использовал?
* Unit-тесты (модульные) проверяют, правильно ли работает каждый отдельный модуль кода. Модульные тесты не должны проверять внешние зависимости или взаимодействия.
* Интеграционные тесты (Integration tests) проверяют взаимодействие между отдельными модулями кода. Также проверяют внешние соединения.
* Функциональные тесты. Проверяют результаты выполнения некоторых действий, которые нужны в бизнес-требованиях, но при этом не проверяют промежуточное состояние системы. Отличия от интеграционных в том, что интеграционные тесты проверяют возможность запросы в бд, а функциональные проверяют возвращаемое значение из бд на соответствие требованиям.
* End-to-End (сквозные) проверяют работу всей интегрированной системы. Копируется поведение пользователя при работе с ПО в контексте всего приложения. Раньше использоваол Selenium. Сейчас Playwright
* Проверка работоспособности (Smoke test, Sanity check) - Проверка основной функциональности приложения. Главная цель - убедиться в работоспособности системы. Полезны после создания новой сборки для определения, можно ли запускать более ресурсоемкие тесты, либо после развертывания в новой среде, чтобы убедиться, что все работает корректно.
* Регрессионное тестирование (Regression testing) Это может быть любой вид теста из описанных выше, который пишется после того, как была обнаружена проблема. Тест должен эмулировать в точности шаги для воспроизведения проблемы. Наличие такого теста после исправления проблемы дает гарантию, что точно такой же баг, больше не появится в системе.
* Проверка на уязвимости (Penetration test, Pentest)
* Нагрузочное тестирование (Load testing)
* Приемочные тесты. Формальные тесты, которые проверяют, отвечает ли система требованиям бизнеса.
* Тестирование производительности (Performance testing)

2 f
Чем интеграционное тестирование отличается от функционального
Интеграционное и функциональное тестирования - это две фазы в процессе тестирования программного обеспечения. Первое проводится после модульного тестирования, а второе - метод тестирования черного ящика.
Функциональное тестирование также упоминается как тестирование Е2Е для тестирования браузера.

3 f
Что такое Mock (имитация, подделка)?
Более продвинутая заглушка (по сравнению со stub). Имитирует поведение и проверяет взаимодействие.
```
import unittest.mock
	
class User:
  def __init__(self, name, email):
      self.name = name
      self.email = email
	
class UserService:
    def __init__(self, user_repository):
        self.user_repository = user_repository
	
    def get_user(self, user_id):
        user = self.user_repository.get_user_by_id(user_id)
        if user:
            return f"User: {user.name}, Email: {user.email}"
        return "User not found"
	
	
class UserRepositoryStub:
    def get_user_by_id(self, user_id):
        if user_id == 1:
            return User(name="Test User", email="test@example.com")
        return None
	
# Пример использования stub:
repo_stub = UserRepositoryStub()
user_service = UserService(repo_stub)
user_info = user_service.get_user(1)
assert user_info == "User: Test User, Email: test@example.com"
	
# Пример использования Mock
mock_repository = unittest.mock.Mock()
mock_repository.get_user_by_id.return_value = User(name="Test User", email="test@example.com")
user_service = UserService(mock_repository)
user_info = user_service.get_user(1)
# Проверка, был ли вызван метод get_user_by_id с аргументом 1
mock_repository.get_user_by_id.assert_called_once_with(1)
assert user_info == "User: Test User, Email: test@example.com"
```

4 f
Что такое Stub?
Заглушка для замены реального объекта.

5 f
Что такое pytest, unittest?
* unittest - модуль тестирования в Python по умолчанию. Объектно-ориентированная структура. Наследуем от класса unittest.TestCase.
* pytest - отдельный фреймворк для тестирования. Есть поддержка fixtures, параметризованного тестирования. Используется в тестах Django.

6 f
Что такое фикстура?
Создают среду для тестирования (очистка файлов от предыдущих тестов, запуск и заполнение БД, получение JWT токена, очистка/наполнение кэша). Используем @pytest.fixture().
TODO: example

7 f
Что такое параметризация тестов?
Позволяет запускать тесты с различными наборами данных. @pytest.mark.parametrize. Т.е. в один тест мы передаём разные наборы даных и ожидаемый результат.

8 f
Что такое скоупы?
Задает область работы fixture и может принимать следующие значения: session, package, module, class, function.  По умолчанию - function.

9 f
Что делать, если тестируемая функция использует удалённое подключение к внешним сервисам, которое иногда видает ошибку таймаута, 404 и им подобные?
Если мы говорим про юнит тесты, то они не должны вызывать внешние ресурсы, то есть делать http запросы и тд. Следовательно нужно замокать http-клиент, который использует функция для вызова сервиса.

10 f
Что делать, если тестируемая функция занимает много времени на выполнение повторяющихся операций внутри неё
Например, внутри цикл от 1 до 1000000, где что-то считывается, записывается, рассчитывается.
Допустим у этой функции нет проблем с декомпозицией - это функция, которая выполняет одно действие и разбивать ее на несколько других не имеет никакого смысла. В таком случае я бы:
* сделал бы возможным заменить из теста верхнюю границу цикла (через параметр или мокая константу, настройку и т.д.)
* если функция вызывает для расчетов другую ресурсоёмкую функцию, стороннюю или из своей кодовой базы, то возможно замокал бы ее и проверил что она вызывается с нужными параметрами
* по возможности подготовил бы для теста такой входящий набор данных, при котором она выполялась быстро
Если функция не соответсвует условиям, описанным в первом предложении, следовало бы сначала заняться ее декомпозицией.


11 f
В чем заключается метод черного и белого ящика в тестировании? Когда он нужен?
Метод черного ящика. Модуль приложения тестируется по входным и выходным данным без анализа структуры кода самого модуля. Чаще всего применяется, когда проверку выполняет тот, кто не участвовал в создании кода модуля и сам код недоступен.
Метод белого ящика. Тестируется внутренняя структура модуля, его возможности и особенности поведения. Компонент изначально виден разработчику. Unit-тестирование методом белого ящика состоит из 3 этапов:
* Анализ отдельного модуля. Нужно изучить внутреннюю структуру кода, функционал и поведение объекта. 
- Создание тест-кейсов. Составление сценариев, чтобы показать, как ведет себя модуль.
- Тестирование модуля. Проверяемый компонент, изолированный от ядра приложения и других модулей, запускается в тест-кейсе.

12 f
Для чего нужны setup и teardown? Когда они запускаются?
Setup - настройка окружения.
Teardown - очистка окружения.
Могут запускаться на уровне функций, на уровне модуля (один раз перед и после всех текстов модуля), на уровне класса.

13 f
Что такое patch в pytest?
Временно заменяет объект на mock-объект (заглушку) во время выполнения теста. Используется как контекстный менеджер через unittest.mock.patch. Также есть в pytest.
TODO: practice

# network 36

1 f
Что такое CGI (Common Gateway Interface), плюсы, минусы?
Соглашение о том, как веб-сервер взаимодействует с программой. Веб-сервер запускает программу как исполняемый файл. Параметры запроса передаются через переменные окружения.
Программа должна записать в стандартный поток вывода HTTP-ответ.

2 f
Как защитить куки от воровства и от подделки
Выставлять кукам флаг httponly. Браузер не даст прочесть и изменить такие куки на клиенте в js.
`Set-Cookie: [cookie_name]=[cookie_value]; HttpOnly`
Использовать флаг secure. Куки будут переданы только по безопасному соединению.
Указать параметр SameSite. Для борьбы с CSRF (Cross-Site Request Forgery).
Устанавливать короткий срок жизни куки.
Устанавливать короткий срок сессии на сервере.
Ограничить путь для куки (параметр Path): `https://test.com/some_app`

3 f
Какая разница между аутентификацией и авторизацией?
* Аутентификация: проверка личности пользователя с помощью некой уникальной информации (пароль, смс, отпечатки пальцев).
* Авторизация - это проверка и определение полномочий на выполнение некоторых действий (например, чтение файла) в соответствии с ранее выполненной аутентификацией.
Процесс:
* Сначала получают идентификатор (логин, email или номер) – идентификация
* Затем проверяют пароль (ключ или отпечаток пальца) – аутентификация
* И в конце предоставляют доступ – авторизация

4 f
Что такое XSS (Cross Site Scripting). Примеры. Как защитить приложение?
Страница, подверженная уязвимости, вынуждает пользователя выполнить запрос к другой странице, либо запустить нежелательный js-код.
Например, пользователь отправил комментарий, в котором был код:
`<script>alert('foo');</script>`. Если нет санации ввода, то все кто зайдет на страницу с опасным комментарием, увидит всплывающее окно с тестом foo.
Уязвимость устраняется экранированием небезопасных символов, чисткой (санацией) HTML-тегов.
TODO: в django и в fastapi

5 f
Что такое REST (Representational state transfer)?
Соглашение о том, как выстраивать сервисы. Как правило, это веб-приложение с набором урлов – конечных точек. Урлы принимают и возвращают данные в формате JSON. Тип операции задают методом HTTP-запроса, например:
* GET – получить объект или список объектов
* POST – создать объект
* PUT – обновить существующий объект
* PATCH – частично обновить существующий объект
* DELETE – удалить объект
* HEAD – получить метаданные объекта
Для веб-служб, построенных с учётом REST, применяют термин RESTful. REST определяет 6 архитектурных ограничений, соблюдение которых позволит говорить о RESTful API:
* Единообразие интерфейса. Ресурс в системе должен иметь только один логичный URI, который должен обеспечивать способ получения связанных или дополнительных данных.
* Клиент-сервер
* Отсутствие состояния. Сервер не будет хранить информацию о последних HTTP-запросах клиента.
* Кэширование
* Слои. Слои REST позволяет вам использовать многоуровневую архитектуру системы, в которой вы развертываете API-интерфейсы на сервере A, храните данные на сервере B, a запросы аутентифицируете, например, на сервере C. Клиент обычно не может сказать, подключен ли он напрямую к конечному серверу или к посреднику.
* Код по требованию (необязательное ограничение). Клиенты могут вызывать ваш API для получения кода визуализации виджета интерфейса пользователя. Это разрешено.

6 f
Что такое SOAP
SOAP (Simple Object Access Protocol - простой протокол доступа к объектам) - протокол обмена структурированными сообщениями в распределённой вычислительной среде. Первоначально SOAP предназначался в основном для реализации удалённого вызова процедур (RPC). Сейчас протокол используется для обмена произвольными сообщениями в формате XML. SOAP может использоваться с любым протоколом прикладного уровня: SMTP, FTP, HTTP, HTTPS и др. Чаще всего SOAP используется поверх HTTP.

7 f
В чем разница между REST и SOAP веб сервисами?
* REST поддерживает различные форматы: text, JSON, XML; SOAP - только XML,
* REST работает только по HTTP(S), а SOAP может работать с различными протоколами,
* REST может работать с ресурсами. Каждый URL это представление какого-либо ресурса. SOAP работает с операциями.

8 f
Можем ли мы посылать SOAP сообщения с вложением?
Да, это возможно. Можно посылать вложением различные форматы: PDF, изображения или другие двоичные данные.

9 f
Как бы вы решили какой из REST или SOAP веб сервисов использовать?
REST против SOAP можно перефразировать как "Простота против Стандарта". В случае REST (простота) у вас будет скорость, расширяемость и поддержка многих форматов. В случае с SOAP у вас будет больше возможностей по безопасности (WS-security) и транзакционная безопасность (ACID).

10 f
Что такое HTTP (HyperText Transfer Protocol)?
Текстовый протокол, работающий поверх TCP/IP. HTTP состоит из запроса и ответа. Их структуры похожи: стартовая строка, заголовки, тело ответа.
Клиент формирует запрос и отправляет его на сервер, после чего сервер обрабатывает запрос, формирует ответ и передаёт его обратно клиенту.

11 f
Как устроен протокол HTTP? 
Стартовая строка запроса состоит из метода, пути и версии протокола: `GET /index.html HTTP/1.1`.
Стартовая строка ответа состоит из версии протокола, кода ответа и текстовой расшифровке ответа.`HTTP/1.1 200 OK`
Заголовки – это набор пар ключ-значение, например, User-Agent, Content-Type. В заголовках передают метаданные запроса: язык пользователя, авторизацию, перенаправление. Заголовок Host должен быть в запросе всегда.
Тело ответа может быть пустым, либо может передавать пары переменных, файлы, бинарные данные. Тело отделяется от заголовков пустой строкой.

12 f
Версии HTTP?
Используется версия 1.1. Но уже доступна версия 3.
HTTP2:
* Мультиплексинг. Запросы и ответы асинхронны. Можно отправлять несколько запросов в одном соединении.
* Автоматическое сжатие. 
* Восстановление соединения.
* Протокол бинарный.
HTTP3:
* Использует QUIC (Quick UDP Internet Connections).
* Быстрое соединение. Позволяет уменьшить проблемы с задержкой в медленных соединениях.
Включаются в nginx.

13 f
Написать raw запрос главной Яндекса.
```
GET / HTTP/1.1
Host: ya.ru
```

14 f
Как клиенту понять, удался запрос или нет?
Проверить статус ответа. Есть пять групп:
1xx: 100 Continue. Сервер получил заголовки запроса и готов продолжать. 101 Switching Protocols (на другую версию HTTP или WebSockets).
2xx: запрос прошел успешно (данные получены или созданы). 200 OK, 201 Created.
3xx: перенаправление на другой ресурс. 301 Moved Permanently (в Location новый адрес), 307 Temporary Redirect, 308 Permanent Redirect.
4xx: ошибка клиента (нет такой страницы, нет прав на доступ). 400 Bad Request, 401 Unauthorized, 404 Not Found.
5xx: ошибка сервера (ошибка в коде, сети, конфигурации). 500 Internal Server error.

15 f
Что нужно отправить браузеру, чтобы перенаправить на другую страницу
308, заголовок Location указывает адрес ресурса, на который следует перейти.
В теле ответа можно разместить HTML со ссылкой на новый ресурс. Тогда пользователи старых браузеров смогут перейти вручную.

16 f
Как управлять кешированием в HTTP?
* Заголовок Cache-Control. Время жизни, публичные/приватные данные, 
* etag (entity tag). Хэш содержимого или времени обновления: дай мне ресурс, если его etag отличается от моего.
* expires. Устарел. Для обратной совместимости.

17 f
Как кэшируются файлы на уровне протокола?
Заголовок etag - хэш файла. Передаётся клиенту. Используется в следующем запросе. Если хеш не совпадает (файл обновили), сервер отвечает с кодом 200 и выгружает актуальный файл с новым хешем. Если хэши равны, сервер отвечает с кодом 304 Not Modified с пустым телом. В этом случае браузер подставляет локальную копию файла.

18 f
Чем отличаются HTTP и HTTPS?
HTTP — прикладной протокол передачи данный, используемый для получения информации с веб-сайтов. 80 порт.
HTTPS — расширение протокола HTTP, поддерживающее шифрование по протоколам SSL и TLS. 443 порт.

19 f
Что такое RPC (Remote Procedure Call)?
Удалённый вызов процедур — класс технологий, позволяющих компьютерным программам вызывать функции или процедуры удалённо. На транспортном уровне RPC используют в основном протоколы TCP и UDP, однако, некоторые построены на основе HTTP.

20 f
Что такое gPRC?
gRPC — это фреймворк от Google для вызов удаленных процедур, работает поверх HTTP/2. gRPC подходит для создания распределенных систем (микросервисов) и API. Имеет встроенную поддержку для балансировки нагрузки, трассировки, аутентификации и проверки жизнеспособности сервисов. Высокая производительность достигается за счет использования протокола HTTP/2 и Protocol Buffers.
* Protobuf вместо JSON.
* HTTP/2 в качестве транспорта.
* Нет привязки методов к HTTP-методам, никакого привязывания возвращаемых значений к HTTP-статусам. 
* SSL/TLS, OAuth 2.0, аутентификация через сервисы Google.
* Поддержка gRPC в публичных API от Google. Уже работает для некоторых сервисов.

21 f
Что такое куки. Зачем они, как с ними работать и где они сохраняются?
Пары ключ-знаения, сохраняемые в браузере веб-сайтом. Куки хранят настройки для сайта, например город. При запросе на сайт, браузер отправляет обратно куки, которые принадлежат этому сайту. Это позволяет сайту запоминать информацию о предыдущих посещениях.
Django использует куки чтобы хранить идентификатор сессии (или позволяет настроить проект чтобы хранить сессию в куках).

21 f
Может ли сервер изменить (добавить, удалить) куки?
Да. Значение куки может быть изменено сервером путём отправления новых строк Set-Cookie: name=newvalue. После этого браузер заменяет старое куки с тем же name на новую строку.

22 f
Что такое JWT (JSON Web Token)?
JSON объект, который позволяет безопасно передавать данные между клиентом и сервером. Состоит из заголовка (тип токена, алгоритм шифрования), полезной нагрузки и подписи.
Может использоваться для аутентификации или обмена информацией.
По сети передаётся в сериализованном формате: `[header].[payload].[signature]`.
В десериализованном виде хранится только заголовок и нагрузка.
```
header:
{
  "alg" : "HS256",
  "typ" : "JWT"
}
Payload:
{
  "id" : 123456789,
  "name" : "Joseph"
}
Secret: GeeksForGeeks
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MTIzNDU2Nzg5LCJuYW1lIjoiSm9zZXBoIn0.OpOSSw7e485LOP5PrzScxHb7SR6sAOMRckfFwi4rp7o
```
TODO: в Django блоке. Добавить информацию как происходит аутентификация [смотреть здесь](https://habr.com/ru/articles/538040/) как передаются токены [смотреть здесь](https://habr.com/ru/articles/842056/)

23 f
Ты зашел в браузер, вбил google.com, нажал enter. Расскажи что происходит дальше по порядку в браузере?
* Поиск IP-адреса (если он неизвестен ОС) через DNS сервер (который может быть установлен у провайдера).
* После получения адреса устанавливается TCP/IP соединение. Обычно по TCP-порту 80.
* Браузер отправляет HTTP GET запрос.
* Получает HTTP ответ. В данном случае HTML.
* Рендерит HTML. Формирует DOM, запрашивает статичные файлы.

24 f
Что такое URL?
Uniform Resource Locator - адрес ресурса в Интернет.
`https://test.com/path/?ref=home-articlecards#what-is-array`
Протокол. Имя домена. Порт необязательно указывать. Путь. Набор параметров. Решётка для перехода к конкретному месту на странице.

25 f
Что такое DNS?
Domain Name System - система для получения информации о доменах. Чаще всего используется для получения IP-адреса по имени хоста. Цель DNS — преобразование удобочитаемых доменных имён в читаемые IP-адреса.

26 f
В чем отличия TCP и UDP?
Оба являются протоколами транспортного уровня.
Transmission Control Protocol (TCP). Устанавливает соединение перед передачей данных и поддерживает его до завершения коммуникации. Гарантирует надёжную передачу данных.
User Datagram Protocol (UDP). Отправляет данные без установления соединения и не гарантирует доставку, порядок или проверку ошибок. Быстрее.

27 f
Что ты знаешь про модель OSI? TCP/IP?
Сетевая модель OSI (Open Systems Interconnection). Состоит из уровней (с самого нижнего):
* Физический. Провода, хабы, беспроводная передача.
* Data Link (канальный). Frames (кадры). Ethernet, физическая адресация, MAC.
* Network. Пакеты. IP и определине пути (логическая адресация).
* Transport. Сегменты, End-to-End connections. TCP, UDP
* Session (сеансовый). Данные. Управление сеансом связи. API's, Sockets
* Presentation (представления). Данные. Представление и кодирование данных. SSL,  MPEG, FTP
* Application (прикладной). Данные. Доступ к сетевым службам. End User Layer. HTTP, SSH.

28 f
Что такое IP-адрес?
IP-адрес (Internet Protocol address) — виртуальный адрес, который присваивается любому устройству в сети. Состоит из адреса подсети и адреса хоста. Чтобы узнать какие числа относятся к подсети, а какие к хосту используется маска подсети.

29 f
Какие ты знаешь HTTP методы?
GET, POST (передача даных в теле сообщения), PUT (создаёт новый ресурс если не существует или обновляет существующий), PATCH (PUT, только по отношению к части ресурса), DELETE, HEAD (не получаем ответа тела, можно проверить существует ли ресурс), условный GET (If-Modified-Since), частичный GET (для докачки файлов). 
Все методы кроме POST являются идемпотентными. Повторные POST-запросы с одинаковыми данными могут создавать несколько ресурсов.


30 f
Что такое query-параметры?
Параметры запроса. Позволяют передать данные на сервер. Обычно используется с GET (но необязательно). Записываются в пути через & в виде пары ключ=значение после ?.
Имеет такой же формат, как и тело запроса с MIME application/x-www-form-urlencoded, только первая пара значений отделяется от адреса вопросительным знаком. Остаются в истории браузера и в логах сервера.

31 f
Как отправить файл по сети?
Метод POST,
Content-Type: multipart/form-data; boundary=----xyz123
Файл помещается в тело, которое делится на нескольк частей, разделяемых boundary.

32 f
Что такое HTTP-стриминг?
Потоковая передача данных (аудио, видео). Непрерывная передача данных от сервера к клиенту.

33 f
Что такое кеширование?
Сохранении копии полученного ресурса для возврата этой копии в ответ на дальнейшие запросы.
Приватный кеш предназначен для отдельного пользователя. Он используется для доступа к ранее загруженным страницам при навигации назад/вперёд, позволяет сохранять страницы, или просматривать их код, не обращаясь лишний раз к серверу.

34 f
Что такое DHCP?
DHCP (Dynamic Host Configuration Protocol) — это сетевой протокол, который позволяет сетевым устройствам автоматически получать IP-адрес для доступа в сеть. Также назначает маску подсети и шлюз по умолчанию.

35 f
Что такое OpenAPI? Что принимает? Связь с SwaggerUI?
OpenAPI — это стандарт для описания RESTful API. YAML или JSON.
Swagger UI — инструмент для визуализации и тестирования API на основе OpenAPI-спецификаций.


36 f
Как можно сделать приложение безопаснее
Аутентификация и авторизация.
Защита данных. Шифрование, резервное копирование.
Защита от уязвимостей. SQL-инъекции: параметризованные запросы или ORM. XSS (межсайтовый скриптинг): Санируйте пользовательский ввод и экранируйте вывод. CSRF (межсайтовая подделка запроса): токены CSRF для защиты форм.
Использование токенов.
Защита от перебора паролей.
Защита сессий: Используйте безопасные куки (флаги HttpOnly, Secure, SameSite).
Защита от кликджекинга: Используйте заголовок X-Frame-Options для предотвращения встраивания вашего приложения в iframe.
CORS (Cross-Origin Resource Sharing): Настройте CORS для ограничения доступа к вашему API с других доменов.

# git 14

1 f
Какие ты знаешь удаленные репозитории?
Github, Gitlab, Bitbucket. Отличия в интерфейсе, названиях и фичах.

2 f
Как можно создать ветку?
```
git branch <name>
git checkout -b <name>
```
Первая команда создаст ветку, вторая создаст и переключится в эту ветку.

3 f
Что такое git stash?
Эта команда позволяет на время архивировать изменения сделанные в рабочей копии. Изменения хранятся локально. 
```
git stash save # создаёт архив и очищает рабочую область
git stash save "Some note"
git stash save -u # include untracked
git stash save -a # all 
	
git stash list # list all stashes
git stash show # list of files of last stash
git stash apply # apply but not delete last stash
git stash pop # удаляет последнее сохранение
git stash bracnh <name> # branch from stash, stash is deleted
git stash drop stash@{n} # delete stash n
git stash clear # delete all stashes
```

4 f
Что такое индекс (staging area)?
Индекс в Git — это специальная промежуточная область, в которой хранятся изменения файлов на пути от рабочей директории до репозитория. При выполнении коммита в него попадают только те изменения, которые были добавлены в индекс.

5 f
Какие ты знаешь способы отката коммита?
* `git reset --soft <commit>` - указатель HEAD перемещается на указанный коммит. Индекс и рабочий каталог остаются без изменений.
* `git reset --mixed` - по умолчанию. Сбрасывается индекс.
* `git reset --hard` - очищается и рабочий каталог.
git reset меняет историю.
TODO: practice

6 f
Какой процесс добавления кода в репозиторий?
Создать отдельную ветку, выполнить изменения, добавить их в индекс, сделать коммит, запушить в удаленный репозиторий. Дальше создается пулл/мерж реквест, назначается ревьюер и затем происходит мерж в мастер.
TODO: practice

7 f
Что такое `git merge`?
Слияние двух веток. Делается из ветки, в которую нужно включить изменения. В результате будет создан коммит слияния (у этого коммита больше одного предка).
```
git checkout master
git merge fix # branch with a name fix
```
Если есть конфликты, запускаем `git mergetool`.
TODO: example of mergetool

8 f
Что такое `git rebase`?
Способ объединить ветки. rebase берёт все коммиты из одной ветки и в том же порядке применяет их к другой ветке. При этом переписывает историю
```
git checkout experiment
git rebase master
git rebase -i # интерактивный режим, позволяет редактировать список коммитов
```
Нельзя перебазировать коммиты, уже отправленные в публичный репозиторий.

9 f
Чем отличается git merge от git rebase?
Результат обоих операций одинаковый. Но будет разная история. В случае с rebase она будет "чище" - линейной.

10 f
Что такое Git Flow?
Git flow стратегия создания ветвей.
В мастере храним только стабильный код, готовый к деплою на продакшн. Здесь же создаём тэги версий.
Ветка разработки, куда мы интегрируем другие ветки.
Feature branch - каждая новая фича в отдельной ветке. Создаётся из ветки разработки и затем мержится туда же по завершении.
Релизная ветка. Создаётся из ветки разработки при подготовки релиза. Новые фичи сюда не добавляются, только исправляем ошибки. Потом сливаем с master и development.
Hotfix branch. Создаётся из основной, решается проблема, потом мержится в master и dev.

11 f
Что такое `git cherry-pick`?
Используется для перенесения отдельных коммитов из одного места репозитория в другое, обычно между ветками разработки и обслуживания. Этот механизм отличается от git merge и git rebase, которые переносят коммиты целыми цепочками.
`git cherry-pick <commit-hash>`

12 f
Что такое git push --force?
Force push перезапишет существующие изменения в репозитории. Позволяет переписать историю (существующие коммиты).
`git push --force origin <имя_ветки>`
Более безопасный вариант (если кто-то успел запушить свои коммиты после того, как мы забирали изменения с сервера):
`git push --force-with-lease origin <имя_ветки>`
Если выдаст ошибку, то мы интегрируем чужие коммиты со своими изменениями и пытаемся ещё раз.

13 f
Что такое pre-commit check
git hook - небольшой скриптовый файл, который автоматически запускается при определённых событиях: коммит, пуш...
Для pre-commit создаём файл .git/hooks/pre-commit
pre-commit запускается при выполнении команды git commit.
В пре-коммите можно запустить линтер, юнит-тесты.

14 f
Как сделать merge если другой разработчик доработал класс и git жалуется.
```
git fetch origin # убеждаемся, что ветка актуальна
git pull origin # или эта
git merge <branch-name>
git diff # просмотреть конфликты
# Открываем файл с конфликтом, редактируем
git add <filename>
git commit 
```



# db 80

1 f
Какие ты знаешь виды баз данных?
Существуют реляционные и нереляционные СУБД. Реляционные – PostgreSQL, MySQL. Нереляционные – MongoDB, Redis, Cassandra, ElasticSearch

2 f
Зачем нужны нереляционные БД если есть реляционные?
Для задач в которых реляционные СУБД показывают себя хуже.
Redis для кеширования.
ElasticSearch для полнотекстового поиска.
Колоночные БД для агрегации запросов на больших объемах данных (sum, avg)

3 f
Какие могут быть отношения между таблицами в реляционной СУБД?
Один к одному, один ко многим, многие ко многим. Эти отношения организуются путем добавления колонок с внешними ключами на другие таблицы. В случае отношения многие ко многим нужна промежуточная таблица.

4 f
Проставь отношения между таблицами: есть пользователь. Пользователи могут друг с другом дружить. У каждого пользователя есть профиль. В профиле можно добавить несколько социальных сетей.
Дружба пользователей это многие ко многим с промежуточной таблицей. Пользователь - профиль – это один к одному. А профиль - социальные сети  – один ко многим.

5 f
Что такое транзакция?
Это последовательность операций. Транзакция является единицей работы с базой данных.

6 f
Что такое ACID?
Основные свойства транзакции: Atomicity, Consistency, Isolation, Durability (Атомарность, Согласованность, Изолированность, Долговечность).
* Атомарность гарантирует, что любая транзакция будет зафиксирована только целиком. Если одна из операций в последовательности не будет выполнена, то вся транзакция будет отменена. Для этого начало транзакции отмечается командой BEGIN, а конец — либо COMMIT, либо ROLLBACK.
* Согласованность означает, что любая завершённая транзакция фиксирует только допустимые результаты. Например, при переводе денег с одного счёта на другой, в случае, если деньги ушли с одного счёта, они должны прийти на другой.
* Изолированность: результат транзакции не должен зависеть от выполнения других параллельных транзакций.
* Долговечность гарантирует, что после того как даные зафиксированы, они не должны потеряться, даже в случае сбоя.
TODO: hard

7 f
Какие виды несогласованности данных есть?
* Lost update - потерянное обновление. При одновременном изменении одного блока данных разными транзакциями теряются все изменения, кроме последнего
* Dirty read - грязное чтение. Чтение данных, добавленных или изменённых транзакцией, которая впоследствии откатится.
* Non-repeatable read - неповторяющееся чтение. При повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными. Разные данные в одной строке.
* Phantom reads - фантомное чтение. Два одинаковых запроса возвращают разный набор строк.

8 f
Что такое уровни изоляции?
Степень защиты от несогласованности данных. Насколько параллельные транзакции изолированы друг от друга.
* Read uncomitted - низший самый слабый уровень. Считываются данные незавершённых транзакций.
* Read committed. Используется по умолчанию в PostgreSQL. Можно читать только зафиксированные транзакции. Защита от грязного чтения, но есть неповторяющееся чтение и фантомное чтение. В базе данных есть несколько версий строк. Делается снимок. Высокий уровень параллелизма.
* Repeatable read. Читающая транзакция не видит изменения данных, которые были ею ранее прочитаны - каждая транзакция видит тот снимок данных, который был при её начале. При этом никакая другая транзакция не может изменять данные, читаемые текущей транзакцией, пока та не окончена. Защита от неповторяющегося чтения. Другая транзакция может вставлять данные - возможно фантомное чтение.
* Serializable. Транзакции полностью изолируются друг от друга. Результат выполнения нескольких параллельных транзакций должен быть таким, как если бы они выполнялись последовательно. Только на этом уровне параллельные транзакции не подвержены эффекту «фантомного чтения».
```
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

9 f
Что такое VACUUM в PostgreSQL?
VACUUM очищает мёртвые кортежи. Можно указать таблицу, иначе будут очищены все таблицы. Другие варианты:
* VACUUM FULL - полная перестройка таблицы и её индексов. Максимальная очистка, но эксклюзивная блокировка таблицы.
* VACUUM ANALYZE - помимо очистки, ещё и обновляет статистику, используемую оптимизатором запросов, чтобы определить наиболее эффективный план выполнения запросов.
* VACUUM VERBOSE - мониторинг очистки. Выводит подробный отчёт о действиях процесса очистки.
* AUTOVACUUM - запускается периодически.

10 f
Что такое колоночная БД?
В такой базе данных данные хранятся и организуются по колонкам. Каждая колонка содержит данные одного типа, и они компактно хранятся в сжатом формате.
Преимущества: более эффективное использование памяти и лучшая сжимаемость, чем в строчных бд, 
Apache Cassandra, ClickHouse — примеры столбцовой СУБД.

11 f
Какие команды управления транзакциями вы знаете?
BEGIN; Начинает транзакцию
COMMIT; Сохраняет изменения
ROLLBACK; Откатывает (отменяет) изменения
SAVEPOINT `<savepoint>`; Создаёт точку к которой группа транзакций может откатиться
ROLLBACK TO `<savepoint>`;
LOCK: Блокировка таблицы  
SET TRANSACTION: Позволяет задавать свойства для текущей транзакции, такие как уровень изоляции и режимы доступа (только чтение или чтение-запись).
RELEASE: Удаление savepoint
Команды управление транзакциями используются только для DML команд: INSERT, UPDATE, DELETE. Они не могут быть использованы во время создания, изменения или удаления таблицы.
TODO: practice

12 f
Что такое EXPLAIN. Какая разница между ним и EXPLAIN ANALYZE
EXPLAIN показывает план выполнения запроса: какие индексы будут использоваться, в каком порядке будут обрабатываться таблицы.
- Не выполняет запрос, а только показывает план.
EXPLAIN ANALYZE показывает план выполнения, выполняет запрос и замеряет время выполнения каждой операции. Аккуратнее с insert, update или delete
```
EXPLAIN (ANALYZE) SELECT * FROM orders WHERE status = 'completed' AND amount > 100;
---
Seq Scan on orders  (cost=0.00..35.00 rows=5 width=64) (actual time=0.005..0.015 rows=5 loops=1)
  Filter: ((status = 'completed'::text) AND (amount > 100))
  Rows Removed by Filter: 95
Planning Time: 0.2 ms
Execution Time: 0.05 ms
```
TODO: practice

13 f
Какие виды JOIN-ов ты знаешь?
* INNER JOIN Для каждой строки из T1 в результирующей таблице содержится строка для каждой строки в T2, удовлетворяющей условию соединения.
* LEFT OUTER JOIN Сначала выполняется внутреннее соединение (INNER JOIN). Затем в результат добавляются все строки из T1, которым не соответствуют никакие строки в T2, а вместо значений столбцов T2 вставляются NULL. Таким образом, в результирующей таблице всегда будет минимум одна строка для каждой строки из T1.
* RIGHT OUTER JOIN Соединение является обратным к левому (LEFT JOIN).
* FULL OUTER JOIN Сначала выполняется внутреннее соединение. Затем в результат добавляются все строки из T1, которым не соответствуют никакие строки в T2, а вместо значений столбцов T2 вставляются NULL. И наконец, в результат включаются все строки из T2, которым не соответствуют никакие строки в T1, а вместо значений столбцов T1 вставляются NULL.
* CROSS JOIN - декартово произведение.
Слова INNER и OUTER необязательны во всех формах. По умолчанию подразумевается INNER (внутреннее соединение), а при указании LEFT, RIGHT и FULL — внешнее соединение. Условие соединения указывается в предложении ON или USING, либо неявно задаётся ключевым словом NATURAL. Это условие определяет, какие строки двух исходных таблиц считаются «соответствующими» друг другу.
Предложение ON определяет наиболее общую форму условия соединения: в нём указываются выражения логического типа, подобные тем, что используются в предложении WHERE. Пара строк из T1 и T2 соответствуют друг другу, если выражение ON возвращает для них true.
USING — это сокращённая запись условия, полезная в ситуации, когда с обеих сторон соединения столбцы имеют одинаковые имена. Она принимает список общих имён столбцов через запятую и формирует условие соединения с равенством этих столбцов. Например, запись соединения T1 и T2 с USING (a, b) формирует условие ON T1.a = T2.a AND T1.b = T2.b.
Более того, при выводе JOIN USING исключаются избыточные столбцы: оба сопоставленных столбца выводить не нужно, так как они содержат одинаковые значения. Тогда как JOIN ON выдаёт все столбцы из T1, а за ними все столбцы из T2, JOIN USING выводит один столбец для каждой пары (в указанном порядке), за ними все оставшиеся столбцы из T1 и, наконец, все оставшиеся столбцы T2.
Наконец, NATURAL — сокращённая форма USING: она образует список USING из всех имён столбцов, существующих в обеих входных таблицах. Как и с USING, эти столбцы оказываются в выходной таблице в единственном экземпляре. Если столбцов с одинаковыми именами не находится, NATURAL JOIN действует как JOIN ... ON TRUE и выдаёт декартово произведение строк.
TODO: practice

14 f
Что такое вложенная транзакция (subtransactions)?
Позволяют разбивать большие транзакции на более мелкие. Начинаются с SAVEPOINT. Можно использовать ROLLBACK TO `<savepoint>` и `RELEASE <savepoint>` - удаляет сэйвпоинт и позволяет продолжить транзакцию с этого места.

15 f
Что такое CTE (Common Table Expressions - обобщённые табличные выражения)?
Временные результаты запроса, которые можно использовать в основном запросе. CTE позволяют структурировать сложные запросы, делая их более читаемыми и удобными для анализа. CTE определяется с помощью ключевого слова WITH. CTE видимы только в рамках текущего запроса.
```
WITH recent_orders AS (
    SELECT * FROM orders WHERE order_date > '2023-01-01'
)
SELECT * FROM recent_orders WHERE total_amount > 100;
```
TODO: practice

16 f
Что такое индекс?
Индекс — объект базы данных, создаваемый с целью повышения производительности поиска данных. Индекс хранит ключи (значения индексируемых столбцов) и ссылки на соответствующие строки в таблице. Структура индекса оптимизирована под поиск, например, сбалансированное дерево.


17 f
Какие ты знаешь индексы?
* Уникальный/Неуникальный (Unique/Non-unique) - могут значения повторяться или нет.
* Простой/составной (Simple/composite) — одно поле/несколько. Порядок полей в составном важен.
* Частичный (Partial Indexes) — подмножество строк таблицы по условию. Только активные пользователи.
* Покрывающий индекс - хранит дополнительные данные в индексе.
* Кластеризованный/некластеризованный.
Типы индексов:
B-tree (сбалансированное дерево) - создается по умолчанию при команде CREATE INDEX. Самый распространённый. Разница в высоте ветвей не может отличаться  больше чем на 1. Поиск происходит так: Если ключ содержится в корне, он найден. Иначе определяем интервал и идём к соответствующему потомку. Повторяем. Каждый узел B-дерева содержит: Ключи (значения индексируемых данных). Ссылки на дочерние узлы (для внутренних узлов). Ссылки на строки таблицы (для листовых узлов).
- идеально подходит для работы с упорядоченными данными и поддерживает операции сравнения (=, <, >, <=, >=, BETWEEN, IN).
- Поддерживает LIKE ‘abc%’, но не ‘%abc’
- Сложность поиска, вставки, удаления О(log(n))
- Индекс b-tree лучше создавать на вариативных данных. Если много одинаковых значений, то он становится неэффективным.
hash
`CREATE INDEX index_name ON table_name USING HASH (column_name)`
- Заточен под операцию сравнения. Нет поиска по диапазону и сортировки. 
- Сложность поиска, вставки, удаления O(1)
GiST (Generalized Search tree - обобщенное дерево поиска)
* Подходит для сложных типов данных, таких как геометрические данные, полнотекстовый поиск 
- занимает меньше памяти, чем GIN
- может быть менее эффективен GIN за счет доп проверок
GIN (Generalized Inverted Index - обобщенный обратный)
- для индексации массивов и наборов значения (ключ-значение, диапазоны и др.)
- для использования более сложного полнотекстового поиска
SP-GiST (Space-Partitioned Generalized Search Tree - GiST с двоичным разбиением пространства)
- GIST для несбалансированных наборов данных, но естественно упорядоченных.(например, телефонные номера, разделенные по городам и странам, но основная часть номера рандомная)
BRIN (Block Range INdex - блочно-диапазонный)
- Эффективен для очень больших таблиц, где данные отсортированы или имеют естественный порядок.
TODO: practice

18 f
Перечислите способы получить количество записей в таблице?
```
SELECT COUNT(*) FROM table1
SELECT COUNT(1) FROM table1 # немного быстрее
SELECT reltuples FROM pg_class WHERE relname = 'orders'; # быстрый на больших таблицах, но приблизительный
```
TODO: practice

19 f
Есть составной индекс INDEX(A,B) и запрос select * from c where b = 1 and a = 2; Применится ли индекс? А в таком запросе: select * from c where b = 1?
Нет, не применится. Порядок колонок в where должен быть таким же, как и в индексе. Во втором случае тоже не применится, т.к. индекс построил в отсортированном порядке по колонке А и только потом по B. Если бы было select * from c where a = 2, тогда индекс бы включился в работу.

20 f
Стандартный кейс составного индекса?
Многие ко многим и эта связка объектов должна быть уникальной. Составные индексы ускорят запросы, в которых задействованы внешние ключи, особенно при сортировках или фильтрациях по нескольким полям. Индексы по внешним ключам нужно создавать вручную.

21 f
В чем отличия кластеризованных и некластеризованных индексов?
* Данные в таблице физически упорядочены по значениям ключа кластеризованного индекса. Листья индекса содержат сами данные (строки таблицы), а не ссылки на них. Таблица может иметь только один кластеризованный индекс.
```
CREATE INDEX idx_employee_id ON employees (employee_id);
CLUSTER employees USING idx_employee_id;
```
* Некластеризованный индекс хранит копию данных индексируемого столбца и ссылки на фактические строки таблицы. Таблица может иметь несколько некластеризованных индексов. Быстрые вставки и обновления, так как данные не переупорядочиваются.
```
CREATE INDEX idx_department ON employees (department);
```

22 f
Шардирование (sharding) и партицирование (partitioning): что это, чем отличаются и когда используются?
Партиционирование — это разбиение таблиц, содержащих большое количество записей.
Партиции, созданные вручную, не наследуют индексы.
При планировке запросов, планировщик выбирает только нужные партиции. Это называется partition pruning.
```
CREATE TABLE sales (
    sale_id SERIAL PRIMARY KEY,
    sale_date DATE NOT NULL,
    amount NUMERIC(10, 2) NOT NULL
) PARTITION BY RANGE (sale_date);
	
-- Партиция для января 2023 года
CREATE TABLE sales_2023_01 PARTITION OF sales
    FOR VALUES FROM ('2023-01-01') TO ('2023-02-01');
-- Партиция для февраля 2023 года
CREATE TABLE sales_2023_02 PARTITION OF sales
    FOR VALUES FROM ('2023-02-01') TO ('2023-03-01');
	
SELECT * FROM sales_2023_01;
```
Шардинг позволяет распределять данные между разными физическими серверами. Процесс шардинга предполагает разнесения данных между отдельными шардами на основе некоего ключа шардинга.
```
-- Шард 1 - на разных серверах
CREATE DATABASE shard_1;
-- Шард 2
CREATE DATABASE shard_2;
-- В shard_1
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    user_id INT NOT NULL,
    product_name TEXT NOT NULL,
    amount NUMERIC(10, 2) NOT NULL
);
-- В shard_2
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    user_id INT NOT NULL,
    product_name TEXT NOT NULL,
    amount NUMERIC(10, 2) NOT NULL
);
```

23 f
Нормализация, что это такое? Какие уровни ты знаешь?
Разделение большой таблицы на небольшие логические единицы - уменьшает избыточность данных.
Нормальные формы:
* Ненормализованная (нулевая) форма (UNF) - Это состояние перед любой нормализацией. В таблице присутствуют избыточные и сложные значения
* Первая нормальная форма (1NF) - Разбиваются повторяющиеся и сложные значения; все экземпляры становятся атомарными
* Вторая нормальная форма (2NF) - Частичные зависимости разделяются на новые таблицы. Все строки функционально зависимы от первичного ключа. Есть составной ключ product_id, order_id. Часть полей зависит от order_id, часть от product_id.
* Третья нормальная форма (3NF) - Транзитивные зависимости разбиваются на новые таблицы. Неключевые атрибуты зависят от первичного ключа. Ключ работник, в таблице храним имя, отдел, название отдела. Название отдела зависит от отдела, а не от работника - нужно разбивать.
* Нормальная форма Бойса-Кода (BCNF) - Транзитивные и частичные функциональные зависимости для всех потенциальных ключей разбиваются на новые таблицы
* Четвертая нормальная форма (4NF) - Удаляются многозначные зависимости
* Пятая нормальная форма (5NF) - Удаляются JOIN-зависимости (зависимости соединения)

24 uf
Что такое денормализация?
Объединение нескольких таблиц в одну. Для избавления от join'ов. Запросы становятся быстрее, но появляется избыточность данных в таблице.
Альтернатива - views (представления)/materialized views. 
Ещё одна: отдельная база данных с денормализованными данными.


25 f
Как можно достичь изоляции транзакций?
lock, select for update, select for share
Lock table - блокирует таблицу для других транзакций до окончания текущей транзакции(есть много разных режимов)
select for update - блокирует строки для других транзакций. Поля записей других таблиц, на которые ссылаются внешние ключи, тоже будут заблокированы(например, первичный ключ).
В конце можно добавить nowait, чтобы селект запрос крашился, если запрашиваемые данные заблокированы другим запросом или недоступны (чтоб не блокировать надолго все остальные вызовы к БД)
Можно добавить skip locked, чтоб были получены только незаблокированные строки.
Строки блокируются в том порядке, в каком они были запрошены.
```
BEGIN;
SELECT * FROM my_table WHERE id = 1 FOR UPDATE;
Другие транзакции не могут ни читать, ни изменять эту строку
COMMIT;
```
SELECT ... FOR SHARE позволяет другим транзакциям читать эти строки, но не изменять их.
```
BEGIN;
SELECT * FROM my_table WHERE id = 1 FOR SHARE;
Другие транзакции могут читать эту строку, но не могут её изменять
COMMIT;
```

26 f
Что ты знаешь о пайплайнах в Redis (redis pipelining)?
Выполняет несколько команд в Redis последовательно.
Клиент отправляет несколько команд и не ждёт ответа на каждую. Сервер сохраняет все и обрабатывает последовательно. Затем возвращает ответ.
```
pipe = r.pipeline()
# Выполняем команды, задаём или получаем значения
response - pipe.execute()
```

27 f
Что такое ORM(Object-Relational Mapping - объектно-реляционное отображение)?
Выполнение запросов к базе данных посредством средств языка программирования. Примеры: Django ORM, SQLAlchemy

28 f
ORM vs raw SQL: плюсы и минусы Raw SQL? 
raw SQL:
* Полный контроль над запросами.
* sql-инъекции, опечатки в SQL.
ORM:
* Абстракция от SQL.
* Безопасность: автоматическая обработка параметров запросов.
* Миграции и управление схемой.
* Избыточные выборки, начальные недостаточные выборки (select n+1).

29 f
Механизм HOT (Heap-Only Tuple):
Если обновление не меняет индексированные столбцы, то PostgreSQL может создать новую версию строки внутри той же страницы данных на диске. Не нужно менять указатели в индексах. Старая строка становится невидимой, а новая занимает ее место.

30 f
Что такое планировщик запросов?
Планировщик запросов или оптимизатор отвечает за создание плана запроса. Он  оценивает несколько альтернативных подходов к решению запроса к базе данных и выбирает наиболее оптимальный план.

31 f
Что такое хинты для планировщика запросов?
В PostgreSQL нет встроенной поддержки хинтов. Есть расширение pg_hint_plan.
Хинты указываются в комментариях к запросу, оформленных с помощью `/*+хинт*/`. Чтобы комментарий интерпретировался как хинт, у него в начале должен стоять знак +, например `/*+ SeqScan(t1) */`.

32 f
Что такое курсор и зачем он нужен?
Используется для обработки данных построчно: работа с большими наборами данных, которые нецелесообразно обрабатывать сразу в памяти.
Обычно используется имплицитный. Но можно задать и явный:
```
BEGIN;
DECLARE my_cursor CURSOR FOR SELECT * FROM my_table;
FETCH FIRST FROM my_cursor;
FETCH NEXT FROM my_cursor;
CLOSE my_cursor;
COMMIT;
	
import psycopg2
	
conn = psycopg2.connect("dbname=test user=postgres")
cur = conn.cursor('my_cursor_name')  # Создание именованного курсора
	
cur.execute("SELECT * FROM large_table")
for row in cur:
    print(row)  # Обработка каждой строки
	
cur.close()
conn.close()
```

33 f
Какая разница между PostgreSQL и MySQL?
Особенности хранения данных. В MySQL для хранения данных в таблицах используются различные движки: MyISAM, InnoDB, MEMORY, Berkeley DB. PostgreSQL работает только на движке storage engine.
Стандарты SQL. MySQL имеет поддержку не всех функций и возможностей SQL. PostgreSQL поддерживает все новые стандарты SQL.
Производительность MySQL и Postgresql. Для организации работы с базой данных в MySQL используется таблица InnoDB. А это значит, что MySQL будет значительно быстрее Postgre в случае использовании первичного ключа. По поводу Postgresql, вся заголовочная информация таблиц размещается в оперативной памяти. Можно применять несколько индексов к одной таблице для большего удобства. В общем PostgreSQL работает быстрее, кроме ситуаций с использованием первичных ключей.
Поддерживаемые типы данных. В Postgre типы более разнообразны.

34 f
Что такое пагинация? Какие есть методы пагинации?
Разбиение большого объема данных на части(страницы) для отправки на клиент. 
- Limit и Offset.
- Курсорная
- Можно использовать CTE.  В блоке with выбираем данные, а затем в запросе используем WHERE BETWEEN.

35 f
Для чего нужно делать recreate index?
REINDEX. Перестраивает индексы.
```
REINDEX INDEX my_index;
REINDEX TABLE my_table;
```
* Фрагментация.
* Индекс содержит не корректные данные - поменялась структура таблицы.
* Может сократить размер индекса.
* Устаревшая статистика.

36 f
Какие операции навешивают table lock?
INSERT, UPDATE, DELETE, SELECT ... FOR UPDATE
INSERT блокирует изменение таблицы, или получение блокировок другими транзакциями, но другие строки не могут обновляться.
CREATE INDEX, LOCK TABLE, REINDEX TABLE, VACUUM FULL.

37 f
Виды блокировок:
* Shared Lock - совместная блокировка, позволяет другим транзакциям читать строку и ставить на нее такую же совместную блокировку. Автоматически устанавливается при выполнении SELECT.
* Exclusive lock исключительная блокировка, запрещает другим транзакциям блокировать строку. UPDATE, DELETE, INSERT накладывают эксклюзивную блокировку.

38 f
Что такое deadlock?
Взаимная блокировка: ситуация, когда две транзакции блокируют друг друга, ожидая, когда другая транзакция освободит блокировку.
Возникает на уровнях Repeatable Read и Serializable при разном порядке запросов.
PostgreSQL ждёт deadlock_timeout и запускает обнаружение взаимных блокировок. Одна транзакция выполнится, на второй возникнет ошибка.
Решается на уровне приложение, повторый запрос неудавшейся транзакции.
Транзакция A обновляет строку X, затем пытается обновить строку Y. Одновременно транзакция B обновляет строку Y, затем пытается обновить строку X.

39 f
В чем разница со стороны построения снэпшотов между Repeatable Read и Read Committed?
Read Committed - снимок создаётся в начале каждого оператора транзакции.
Repeatable Read (Serializable) - снимок создаётся один раз в начале первого оператора транзакции.

40 f
Что такое подзапрос в SQL?
Это запрос внутри другого запроса. Подзапросы всегда выполняются первыми, а результат подзапроса передается в основной запрос.

41 f
Когда нужны реляционные БД?
* Хранение структурированных данных.
* Обеспечение целостности данных.
* Выполнение сложных запросов.
Нереляционные базы:
* Хранение неструктурированных или полиморфных данных.
* Необходимость в низком задержке доступа к простым данным.

42 f
Какие есть виды нереляционных БД?	
* Документоориентированные (MongoDB, CouchDB) - для хранения документов в формате JSON, когда у бизнеса нет четких требований и схема документа нечеткая. Есть relation, но они не предназначены для них.
- Поисковые движки (Elasticsearch, Sphinx) - надстройка над документоориентированными. Хорошо подходит для поиска за счёт оптимизации и гибких настроек движка. (дублировать данные из реляционки в elk) Также подходит для хранения логов.
- Графовые (Neo4j, Microsoft Asure Cosmos DB). Для хранения данных в виде графа - когда хранятся отношения объектов (ребро - вид отношения, узел - объект) - соцсети, рекомендательные системы
- Ключ-значение (Redis, Memcached) - кэширование, быстрый доступ к оперативной памяти, но память ненадежная (для не сильно ценных данных).
- Колоночные (ClickHouse, Cassandra) - Позволяет круто сжимать данные. Подходит для аналитических задач (большие select запросы по нескольким полям)
- Time series (InfluxDB) - для временных промежутков, т.е. для событий, привязанных к временной шкале, например, системы мониторинга и финансовые системы
- Blob Store (Ceph, S3) - для хранения файлов различных форматов, например, картинок или аудио.
- Пространственные (Microsoft SQL) - для работы с объектами определенными в геометрическом пространстве. Это могут быть простые объекты (точки, линии, многоугольники) или сложные (3D-объекты, топологические покрытия, линейные сети). В таких СУБД реализован набор специальных функций, позволяющих проводить с объектами операции создания, трансформации, измерения (расстояния, площади, объема), вычисления (пересечений \ соприкосновений) и выборки по определенным критериям."

43 f
Что такое Views (представления)?
Виртуальная таблица, которая формируется на основе результата выполнения запроса. Не хранит данные физически - данные в представлении всегда актуальны. В отличие от CTE, может использоваться больше одного раза.
```
CREATE VIEW active_users AS
SELECT id, name, email
FROM users
WHERE status = 'active';
SELECT * FROM active_users;
```
Materialized View — это физическая копия данных, которая хранится на диске. Данные обновляются только при явном запросе - REFRESH.
```
CREATE MATERIALIZED VIEW active_users_mv AS
SELECT id, name, email
FROM users
WHERE status = 'active';
	
SELECT * FROM active_users_mv;
	
-- Обновление данных в Materialized View
REFRESH MATERIALIZED VIEW active_users_mv;
```
TODO: practice

44 f
Какие могут быть виды сканирования?
Вид сканирования определяет оптимизатор.
* Index scan - используется если есть большой набор проиндексированных данных и потенциально в результирующий набор запроса попадает малое кол-во строк (например, 1 строка при 1 млн строк в таблице - поиск по primary key)
* Index only scan - данные извлекаются непосредственно из индекса, без необходимости обращаться к самой таблице. Применяется когда все столбцы, запрошенные в SELECT, содержатся в индексе и индекс покрывает все условия в WHERE. Эффективен при покрывающих индексах.
```
CREATE INDEX idx_users_name ON users (name);
EXPLAIN SELECT name FROM users WHERE name = 'Alice';
```
* Bitmap scan - используется при средних размерах результирующего набора запроса. Сначала метод доступа возвращает все TID строк, удовлетворяющих условию, и по ним строится битовая карта версий строк, а затем версии строк читаются из таблицы, при этом каждая страница будет прочитана только один раз. Может работать при поиске более чем по одному индексу, условиях на несколько столбцов, join-ах таблиц 
* Sequential scan (Full Table Scan)- последовательное сканирование. Используется по умолчанию и при больших размерах результирующего набора запроса (999к из 1 млн). Используется  если нет индексов, маленькая таблица.
* Tid scan - сканирование по физическому адресу строки в таблице, редко используется
TODO: practice


45 f
Какие существуют механизмы мониторинга запросов в БД?	
pg_stat — это набор системных представлений.
* pg_stat_activity - содержит информацию о текущих активных соединениях, выполняемых запросах и состоянии процессов.
	* state — состояние соединения (active, idle, idle in transaction).
	* query — выполняемый SQL-запрос.
* pg_stat_statements - можно посмотреть время выполнения запросов. Нужно включать CREATE EXTENSION pg_stat_statements.
* pg_stat_database - содержит агрегированную статистику по базам данных.
	* numbackends — количество активных подключений.
	* xact_commit — количество зафиксированных транзакций.
	* blks_read — количество чтений с диска.
	* blks_hit — количество обращений к кэшу (в памяти).
* pg_stat_conflicts - дедлоки.
* pg_stat_user_tables - предоставляет статистику по пользовательским таблицам.
	* seq_scan — количество последовательных сканирований.
	* idx_scan — количество сканирований индекса.
	* n_tup_ins, n_tup_upd, n_tup_del — количество вставок, обновлений и удалений.
* pg_stat_user_indexes - информация об использовании индексов.
	* relname — имя таблицы.
	* indexrelname — имя индекса.
	* idx_scan — количество раз, когда индекс был использован.
* pg_stat_bgwriter - статистика фоновой записи данных на диск.
	* checkpoints_timed — количество выполненных контрольных точек.
	* buffers_checkpoint — количество буферов, записанных во время контрольных точек.
	* buffers_clean — количество буферов, записанных фоновым процессом.
* pg_stat_replication - отслеживает состояние репликации между мастером и репликами.
	* application_name — имя репликационного приложения.
	* state — состояние репликации (streaming, catchup, startup).
TODO: practice. Добавить про pg_stat_statements в вопросы про оптимизацию/как найти медленный запрос.

46 f
Какие существуют механизмы отказоустойчивости в СУБД?	
Мастер-слейв - основной сервер мастер на запись и реплики-слейвы на чтение.
Журналы транзакций (WAL)
Резервное копирование
Шардирование
ACID

47 f
Что такое WAL (Write-Ahead Logging)?
Механизм обеспечения целостности данных и восстановления после сбоев.
Все изменения данных сначала записываются в журнал (лог), а уже потом постепенно применяются к самим данным.

48 f
Что такое оконные функции?	
Оконная функция в SQL - функция, которая работает с выделенным набором строк (окном, партицией) и выполняет вычисление для этого набора строк в отдельном столбце без необходимости группировать данные и сводить их в одну строку.
```
select name, subject, grade,
sum(grade) over (partition by name) as sum_grade,
avg(grade) over (partition by name) as avg_grade,
count(grade) over (partition by name) as count_grade,
min(grade) over (partition by name) as min_grade,
max(grade) over (partition by name) as max_grade
from student_grades;
```
TODO: practice, hard

49 f
Какой порядок выполнения SQL-запроса?
FROM/JOIN - определение интересующих данных
WHERE - фильтрация записей, не соответсвующих ограничениям
GROUP BY - группировка на основе значений в одном или нескольких столбцах
HAVING - фильтрация данных после группировки.
SELECT - получение всех необходимых столбцов и выражений
DISTINCT
ORDER BY
LIMIT / OFFSET

50 f
В чем отличие между WHERE и HAVING?
WHERE выполняется до агрегатных функций и фильтрует каждую строку, а HAVING - после агрегатных функций и работает с группами строк (если есть GROUP BY, то по группам оттуда, иначе все строки являются одной группой).

51 f
Какие есть агрегатные функции БД?	
Позволяют выполнять операции над множеством строк и возвращать одно итоговое значение.
AVG()
SUM()
COUNT()
MIN(), MAX()
STRING_AGG(a, b) - собирает все значения а в одну строку с разделителем b
ARRAY_AGG() - собирает все значения в массив
BOOL_AND()/BOOL_OR() - возвращает истину, если все/одно значение истина
Можно создавать свои через CREATE FUNCTION

52 f
Как выполняются транзакции в redis?	
Начало Транзакции (MULTI): После неё Redis начинает собирать последующие команды в очередь вместо их немедленного выполнения.
Добавление Команд в Транзакцию: Все команды, отправленные после MULTI и до EXEC или DISCARD, помещаются в очередь и не выполняются сразу. Примеры команд: SET, GET, DEL, INCR, DECR, LPUSH, LPOP
Выполнение Транзакции (EXEC): При получении команды EXEC Redis выполняет все команды из очереди последовательно. Если используется WATCH и отслеживаемые ключи изменились, транзакция будет отменена.
Отмена Транзакции (DISCARD): Команда DISCARD очищает очередь команд и завершает транзакцию без выполнения каких-либо команд.

53 f
Что такое репликация? Когда нужно использовать?
Стриминговая и логическая.
Стриминговая делится на синхронную и асинхронную. Копируется wal.
При логической выполняются запросы.
Синхронное или асинхронное (основной сервер не ждёт подтверждения от реплик) копирование данных между несколькими серверами.
Ведущие сервера используются для чтения и изменения данных, а ведомые — только для чтения.
Настраивается в файлах конфигурации.
Для автоматического переключения на реплику используем pg_auto_failover (есть другие варианты: patroni) - монитор на отдельном сервере. Получается кластер: monitor, master, slave.
```
Настройка асинхронной:
В конфиге настраиваем wal:
wal_level = replica
и в pg_hba.conf настраиваем адрес реплики
```
TODO: usecase


54 f
Какие бывают типы подзапросов?
Некоррелированный подзапрос: Выполняются только один раз перед выполнением внешнего запроса. Результат подзапроса не зависит от строк во внешнем запросе.
Коррелированный подзапрос: Выполняются многократно для каждой строки внешнего запроса. Результат подзапроса зависит от значения столбца текущей строки во внешнем запросе.
```
SELECT *
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);
	
SELECT name, salary
FROM employees e1
WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e1.department = e2.department);
```
TODO: example

55 f
В чем разница между операторами DELETE, TRUNCATE, DROP?
DELETE: Используется для удаления строки в таблице. Можно восстановить данные после удаления. DML-команда. Медленнее, чем оператор TRUNCATE
TRUNCATE: Используется для удаления всех строк из таблицы. Нельзя восстановить данные. DDL-команда. Быстрее.
DROP удаляет таблицу.

56 f
Из каких подмножеств состоит SQL?
DDL (Data Definition Language, язык описания данных) — позволяет выполнять различные операции с базой данных, такие как CREATE (создание), ALTER (изменение) и DROP (удаление объектов).
DML (Data Manipulation Language, язык управления данными) — позволяет получать доступ к данным и манипулировать ими, например, вставлять, обновлять, удалять и извлекать данные из базы данных.
DCL (Data Control Language, язык контролирования данных) — позволяет контролировать доступ к базе данных. Пример — GRANT (предоставить права), REVOKE (отозвать права).

57 f
Что подразумевается под СУБД? Какие существуют типы СУБД?
База данных — структурированная коллекция данных. Система управления базами данных (СУБД) — программное обеспечение, которое взаимодействует с пользователем, приложениями и самой базой данных для сбора и анализа данных. СУБД позволяет пользователю взаимодействовать с базой данных. Данные, хранящиеся в базе данных, могут быть изменены, извлечены и удалены. Они могут быть любых типов, таких как строки, числа, изображения и т. д.

58 f
Что подразумевается под таблицей и полем в SQL?
Таблица — организованный набор данных в виде строк и столбцов. Поле — это столбцы в таблице.

59 f
В чем разница между типом данных CHAR и VARCHAR в SQL?
Это символьные типы данных, но varchar используется для строк переменной длины, тогда как Char используется для строк фиксированной длины. Например, char(10) может хранить только 10 символов и не сможет хранить строку любой другой длины, тогда как varchar(10) может хранить строку любой длины до 10.

60 f
Что такое первичный ключ (Primary key)?
Столбец или набор столбцов, которые однозначно идентифицируют каждую строку в таблице. Нулевые (Null) значения не допускаются.

61 f
Что такое ограничения (Constraints)?
Используются для указания ограничения на тип данных таблицы. Они могут быть указаны при создании или изменении таблицы. Пример ограничений: NOT NULL, CHECK, DEFAULT, UNIQUE, PRIMARY KEY, FOREIGN KEY
```
CREATE TABLE users (
    id SERIAL PRIMARY KEY, # то же уникальный
    email VARCHAR(255) UNIQUE,
    username VARCHAR(255) UNIQUE
);
```

62 f
Как ведёт себя уникальный айди в партицированной базе?
Нужно быть осторожным. Я использую SEQUENCE.
```
CREATE SEQUENCE my_seq START WITH 1 INCREMENT BY 1;
	
CREATE TABLE my_table (
    id NUMBER DEFAULT my_seq.NEXTVAL PRIMARY KEY,
    data VARCHAR2(100)
) PARTITION BY HASH (id) PARTITIONS 4;
```
 Можно использовать uuid или составные ключи.

63 f
Автоинкремент в PostgreSQL?
SERIAL, IDENTITY основывается на последовательностях.
```
id INT GENERATED ALWAYS AS IDENTITY
GENERATED BY DEFAULT AS IDENTITY
```

64 f
Расскажи про кортежи и страницы.
Кортеж — это строка в таблице базы данных.
Страница — это блок фиксированного размера, в котором хранятся кортежи. Размер - 48КБ.
Страницы организованы в файлы данных. 
Страница обычно содержит: Заголовок страницы: Метаданные (например, информация о свободном месте, идентификатор страницы). Кортежи: Данные строк таблицы. Слоты (Slots): Указатели на кортежи внутри страницы.
Для доступа к кортежу база данных сначала находит страницу, а затем слот, указывающий на кортеж.


65 f
Что вы подразумеваете под триггером в SQL?
Триггер в SQL — процедуры, которые автоматически выполняются при наступлении определенных событий. Это позволяет вам выполнить код, когда вставка, обновление или любой другой запрос выполняется к определенной таблице.
Нишевая вещь. У нас используется триггер для партиционирования. Я считаю, что это уже относится к логике. И реализую на уровне приложения. Например через Django-signals. 

66 f
Что такое MVCC (Multi-Version Concurrency Control)?
Механизм управления параллельным доступом к данным в PostgreSQL, который позволяет нескольким транзакциям работать с базой данных одновременно, не блокируя друг друга.
MVCC создаёт версии данных для каждой транзакции.
Обновление проходит так:
* Создание новой версии строки (tuple). Сохраняется в другом месте на диске.
* Изменение указателей.
* Изменение системных каталогов (метаданные о таблицах, индексах...)
* Завершение транзакции. Новая версия строки делается видимой для других транзакций.

67 f
Основные шаги для оптимизации транзакций?
Анализ запроса с помощью EXPLAIN и EXPLAIN ANALYZE.
Использование индексов
Оптимизация условий WHERE. Избегайте функций и вычислений в условиях, так как они могут препятствовать использованию индексов.
```
-- Неэффективно (индекс не используется)
SELECT * FROM users WHERE LOWER(name) = 'alice';
```
Оптимизация JOIN. Убедитесь, что столбцы, используемые в JOIN, индексированы. Используйте INNER JOIN вместо OUTER JOIN, если это возможно, так как INNER JOIN обычно быстрее.
Оптимизация ORDER BY и GROUP BY. Убедитесь, что столбцы в ORDER BY и GROUP BY индексированы. 
Уменьшение количества данных. Выбирайте только те столбцы, которые действительно нужны, вместо `SELECT *`. Используйте LIMIT для ограничения количества возвращаемых строк, если это возможно.
Оптимизация подзапросов
```
-- Неэффективно
SELECT name FROM users WHERE id IN (SELECT user_id FROM orders);
	
-- Эффективно
SELECT u.name FROM users u JOIN orders o ON u.id = o.user_id;
```
Использование представлений и CTE (Common Table Expressions).
```
WITH active_users AS (
    SELECT * FROM users WHERE last_login > NOW() - INTERVAL '30 days'
)
SELECT * FROM active_users WHERE age > 30;
```
Оптимизация работы с большими данными. Для больших таблиц используйте партиционирование.
Анализ и перестройка индексов. Analyze - перестаривает статистику таблиц.
Оптимизация схемы базы данных. Нормализуйте или денормализуйте схему базы данных в зависимости от требований. Убедитесь, что типы данных соответствуют хранимым значениям (например, используйте INT вместо BIGINT, если значения небольшие).
Кэширование.
Мониторинг и анализ. Регулярно мониторьте производительность базы данных с помощью инструментов, таких как pg_stat_activity, pg_stat_user_tables.

68 f
Как работают распределённые транзакциии?
Транзакции, которые охватывают несколько ресурсов (например, базы данных, очереди сообщений, файловые системы), расположенных на разных серверах или в разных системах.
Two-Phase Commit (2PC, Двухфазный commit). Подготовка, фиксация. Блокировка ресурсов на время выполнения транзакции.
Saga.

69 f
Как Postgres пишет данные на диск при завершении транзакции?
PostgreSQL сначала записывает изменения в WAL (журнал предзаписи), а только затем применяет их к основным данным (таблицам и индексам) на диске. Background Writer периодически записывает измененные страницы из буферного кэша на диск.

70 f
Если запрос в базу идеальный, что ещё можно использовать чтобы ускориться?
Индексы, материализованные представления.  Кэширование на уровне редис (например, на 60 секунд).

71 f
По каким портам может подключаться PostgreSQL?
5432 - порт по умолчанию. 
6432 - используется PgBouncer - это прокси-сервер между клиентами и PostgreSQL. Он управляет пулом соединений, чтобы уменьшить нагрузку на сервер базы данных. Ограничивает количество активных соединений. Также может использоваться для балансировки нагрузки при репликации.

72 f
На основе чего планировщик основывает своё решение?
Статистики таблиц и индексов. Количество строк, которые будут возвращены. Есть ли JOIN'ы.
На основе этих оценок вычисляется общая стоимость плана.

73 f
Что можно добавить в запрос добавления индекса, чтобы он был неблокирующим?
```
CREATE INDEX CONCURRENTLY index_name ON table_name (column_name);
```
Обычное создание индекса блокирует таблицу для записи (но не для чтения) на время выполнения операции.


74 f
Что делает ON DELETE?
Опция, которая определяет поведение базы данных при удалении строки. используется в определении внешнего ключа.
`ON DELETE CASCADE` - При удалении записи в родительской таблице автоматически удаляются все связанные записи в дочерней таблице.
`ON DELETE SET NULL`
`ON DELETE SET DEFAULT`
`ON DELETE RESTRICT` - по умолчанию.

75 f
Что такое мягкое удаление (soft delete)?
Данные не удаляются физически из базы данных, а помечаются как удалённые с помощью специального флага или индикатора. is_deleted или deleted_at.

76 f
Какое требование ACID достигается с помощью вторичного ключа?
Consistency. Значение вторичного ключа всегда должно соответствовать значению первичного ключа в связанной таблице. Если попытаться вставить или обновить запись с несуществующим значением вторичного ключа, база данных выдаст ошибку.

77 f
Всегда ли в индексах лежит указатель на данные?
Нет, например, покрывающие.
```
CREATE INDEX idx_users_covering ON users (name) INCLUDE (age);
```

78 f
Откуда берутся мертвые кортежи в бд?
Мёртвые кортежи (dead tuples) — это строки (кортежи), которые больше не видны ни одной транзакции, но всё ещё занимают место на диске.
Когда строка обновляется или удаляется, она помечается как устаревшая (мёртвая). Она остаётся в таблице до тех пор, пока не будет очищена.
Это связано с механизмом MVCC (Multiversion Concurrency Control).
Можем их очистить с помощью VACUUM.
Их можно найти в таблице pg_stat_user_tables.

79 f
В каких случаях лучше не применять индексы?
Если много вставок и мало чтения. Небольшие таблицы. Если много повторяющихся значений.

80 f
Любой ли релиз можно откатить? Что может быть такого, что не хотелось бы откатывать?
Проблема с откатыванием новых полей, которые пользователи уже начали заполнять.



# front 2

1 f
Какие ты знаешь html-теги?
div, br, hr, p, h1-h2...

2 f
Как вы верстали email-письма для отправки?
Стандартные шрифты, встроенные стили. Задаём фоновый цвет, некоторые клиенты не отображают фоновое изображение. Использовать таблицы, задаём атрибуты border, cellpadding, cellspacing. Для картинок прописываем alt.


# wsgi 5

1 f
Что такое nginx, зачем он нужен? Зачем его ставить перед приложением?
* веб-сервер - отдаёт статичные файлы.
* Reverse Proxy Server, API Gateway - обратный прокси-сервер. Обрабатывает запросы приходящие на сервер и направляет их в веб-приложение (uwsgi, gunicorn) 
* Балансировщик нагрузки - распределяет траффик по нескольким серверам.

2 f
Что такое Gunicorn (UWSGI) и для чего он нужен?
WSGI сервер для запуска веб-приложений на Python. 
WSGI - стандарт, описывающий процесс запуска и передачи запроса от серверов к веб-приложениям. WSGI предварительно загружает (делает pre-fork) приложение в оперативную память и держит его там.

3 f
В. Что такое certbot?
Бот для автоматического получения SSL/TLS сертификатов с Let's Encrypt (центр выдачи сертификатов). Обновляет сертификаты каждые 60 дней.

4 f
Что такое балансировщик нагрузки, какие ты знаешь алгоритмы балансировки?
Инструмент для распределения задач между несколькими серверами.
* Round Robin. Распределяет запросы по серверам по очереди.
* Взвешенный Round Robin. Каждому серверу назначается вес, чем больше вес, тем больше количество запросов.
* Least Connections. Равномерное распределение нагрузки.

5 f
Чем Gunicorn отличается от uvicorn?
Gunicorn использует префорк. Создаётся несколько рабочих процессов и каждый обрабатывает один запрос за раз.
uvicorn - асинхронный - может обрабатывать несколько запросов одновременно. Большее количество запросов при меньшем потреблении памяти.


# docker 16

1 f
В чем отличия образов alpine, slim, bookworm для Python? Почему не рекомендуют использовать Alpine?	
В alpine слишком много вырезано и многие инструменты заменены на легковесные. Может быть много багов.
slim - на основе Debian.
Bookwork - кодовая версия Debian  12. Bullseye - Debian 11.

2 f
Как собрать контейнер и запустить его?
```
docker build . -t <tag:v>
docker run -d -p 8080:80 tag:v
```

3 f
Какой флаг нужен, чтобы запустить контейнер в фоне?
Флаг -d

4 f
Что такое volume?
Директория хоста, примонтированная к файловой системе контейнера. Служит для хранения данных.

5 f
Что такое docker compose?
Приложение, которое позволяет запускать множество контейнеров одновременно и маршрутизировать потоки данных между ними.

6 f
Как сделать так, чтобы один контейнер запускался только после старта другого?
```
services:
	web:
		build: .
		depends_on:
			db:
				condition: service_healthy
				restart: true
			redis:
				condition: service_started
	redis:
		image: redis
	db:
		image: postgres
			healthcheck:
				test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
				interval: 10s
				retries: 5
				start_period: 30s
				timeout: 10s
```

7 f
Как посмотреть список запущенных контейнеров?
```
docker ps
docker ps -a # все контейнеры, не только запущенные
docker ps -q # только id контейнеров
```

8 f
Что такое Docker? Для чего он нужен? В чём его преимущества?
Докер позволяет упаковать в единый образ приложение и все его зависимости.
* Разделяет приложение от инфраструктуры.
* Запускает контейнер прямо из ядра основной операционной системы и не виртуализирует оборудование - контейнеризованное приложение может работать только в той же ОС, что и основная. Контейнеры потребляют меньше ресурсов чем ВМ.


9 f
Что какое Docker Registry? Какие ты знаешь? С какими сталкивался в работе?
Платформа для хранения образов. 
hub.docker.co
Amazon Elastic Container Registry
gitlab

10 f
Что такое Docker Swarm?
Docker Swarm  инструмент для кластеризации и оркестрации. Аналог кубера.

11 f
Что ты знаешь о networks в docker?
Можно создавать пользовательские сети и присоединять контейнеры к сети.
Есть несколько сетевых драйверов:
* bridge - сетевой драйвер по умолчанию
* host - убирает сетевую изоляцию между контейнером и хостом Докера. Контейнер не получает свой ip адрес. большое количество открытых портов
* none - полностью изолирует контейнер
* ipvlan - предоставляют полный контроль над ip адресацией.
* macvlan - назначает физический MAC адрес контейнеру.
* overlay - наложенные сети соединяют несколько демонов Docker. Docker swarm.
```
docker network
docker network ls
	
docker network create -d bridge my-net
docker run --network=my-net -itd --name=container3 busybox
	
docker network inspect my-net
```

12 f
Какие параметры принимает docker run?
```
image
--name задаёт имя контейнера
-d запуск в фоновом режиме
-p публикует порты контейнера на хост-машине
-v volume
-e переменные окружения через равно
-rm удаляет контейнер после остановки
-t позволяет использовать терминал внутри контейнера
```

13 f
Сети в докере?
По умолчанию создаётся сеть bridge, в которой находятся все контейнеры, запущенные без указания сети. Каждый имеет ip адрес. Также докер предоставляет встроенный DNS сервис - позволяет контейнерам находить друг друга по именам.
Контейнер может обратиться к хосту по имени `host.docker.internal`.

14 f
Структура докер файла:
```
# 1. Базовый образ
FROM python:3.11-slim-bookworm
# 2. Рабочая директория
WORKDIR /app  # Устанавливаем рабочую директорию внутри контейнера
# 3. Копирование зависимостей
COPY requirements.txt .  # Копируем requirements.txt в рабочую директорию
# 4. Установка зависимостей
RUN pip install --no-cache-dir -r requirements.txt  # Устанавливаем зависимости из requirements.txt
# 5. Копирование исходного кода приложения
COPY . .  # Копируем все файлы и папки из текущей директории в рабочую
# 6. Порт приложения
EXPOSE 8000
# 7. Команда для запуска приложения
CMD ["python", "main.py"]  # Запускаем main.py при старте контейнера
```
Инструкции, которые меняются редко и/или требуют много ресурсов, должны идти в начале Dockerfile. Это позволит использовать кэш сборки, если эти слои не менялись.

15 f
Как диагностировать и устранять проблему, когда ваш Docker Compose проект начинает перезапускаться и не может стабильно подняться?
```
docker-compose logs -f <имя_контейнера>  # Подписаться на логи контейнера в реальном времени
docker-compose logs <имя_контейнера> # Просмотреть прошлые логи контейнера
```
Если в docker-compose.yml вы определили healthchecks, то docker-compose ps покажет статус health этих контейнеров.
Проверить контейнеры от которых зависит проблемный.

16 f
Заходим в контейнер, как понять что что-то работает, а что-то нет?
```
docker exec -it <имя_контейнера> bash # или sh
# смотрим логи в /var/log
ps aux,
top, htop
free, df
```



# message_brokers 14

1 f
Что такое брокер сообщений?
Посредник, обеспечивающий передачу сообщений между различными приложениями. 

2 f
RabbitMQ: плюсы/минусы?
Надёжный - сообщения могут сохраняться на диск.
Поддерживает подтверждения сообщений, различные политики ретрансляции.
Производительность ниже чем у Redis и Kafka.
При обработке очень большого объёма данных могут возникать большие задержки.

3 f
Kafka: плюсы/минусы?
Производительность. Миллионы сообщений в секунду с минимальной задержкой.
Долговечность: Сообщения размещаются на диск и могут быть сохранены по необходимости.
Горизонтальная масштабируемость. Легко добавить новые машины в кластеры.
Сложность: Сложнее в настройке и управлении по сравнению с Redis и RabbitMQ. Настройка и запуск Kafka требуют значительных усилий.
Ресурсоемкость: Требует больше ресурсов для эффективной работы.

4 f
Что лучше использовать: RabbitMQ или Kafka? Как выбрать нужный инструмент под задачу?
Для сбора и агрегации событий из множества источников, метрик и логов лучше использовать Apache Kafka, а RabbitMQ подходит для быстрого обмена сообщениями между несколькими сервисами.

5 f
Какие типы exchange (обменник) ты знаешь в RabbitMQ?
Direct. Прямая отправка сообщений в одну или несколько очередей с совпадающим значением ключа маршрутизации. Используется, когда есть точно известный ключ, по значению которого отдельные приложения-потребители должны получить подходящие сообщения.
Fanout. Все сообщения отправляются во все очереди независимо от ключа маршрутизации. Применяется, когда все приложения-потребители должны быстро получать все сообщения. Самый быстрый.
Headers. Маршрутизация по нескольким атрибутам, заданным в заголовке сообщения. Ключ маршрутизации игнорируется. Используется, когда правила маршрутизации сообщения в очереди сложнее, чем просто по ключу, например, формат данных, комбинация полей и пр.
Topic. Сообщение отправляется в конкретные очереди по значению ключа маршрутизации, заданного по шаблону. Применяется, когда ключ маршрутизации сложный и поток сообщений надо разделить по разным приложениям-потребителям.

6 f
Какие есть виды гарантии доставки сообщений в брокерах?
At most once. Не гарантирует доставку.
At least once. Гарантирует, что сообщение будет доставлено, но может быть и доставлено несколько раз в случае сбоя. Отправитель отправляет сообщение и ждёт подтверждения от RabbitMQ. Получатель обрабатывает сообщение и отправляет подтверждение RabbitMQ о том, что сообщение было обработано. Если подтверждение не получено, RabbitMQ может повторно доставить сообщение. Сообщения сохраняются на диске, что позволяет RabbitMQ восстановить их в случае перезапуска.
Exactly once. RabbitMQ не имеет из коробки.
TODO: example

7 f
Какими библиотеками в питоне осуществляли взаимодействие с rabbitmq?
Если нужен низкоуровневый контроль, используйте pika.
```
import pika
	
# Подключение к RabbitMQ
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()
	
# Создание очереди
channel.queue_declare(queue='hello')
	
# Публикация сообщения
channel.basic_publish(exchange='', routing_key='hello', body='Hello, RabbitMQ!')
print(" [x] Sent 'Hello, RabbitMQ!'")
	
# Закрытие соединения
connection.close()
```
Для асинхронных приложений подойдет aio-pika.
celery. Создаётся экземпляр celery и в качестве брокера выбирается rabbitmq.
```
from celery import Celery
	
# Создание экземпляра Celery
app = Celery('tasks', broker='amqp://guest:guest@localhost//')
	
# Определение задачи
@app.task
def send_message(message):
    return f"Message received: {message}"
	
# Вызов задачи
send_message.delay('Hello, RabbitMQ!')
```

8 f
Почему celery работает с json объектом а не с объектами python?
Есть сериализаторы для разных форматов: pickle, yaml. По умолчанию - json.
Celery поддерживает различные брокеры сообщений (RabbitMQ, Redis). Эти брокеры ожидают данные в текстовом или бинарном формате.
pickle - сериализирует код. Проблемы с безопасностью, можно передать любой код. Разные версии питон - разные pickle.

9 f
Можно ли объект из Django отправить в очередеь celery task?
Можно, но не нужно. Можно использовать pickle. Лучше передать id и вытащить в задаче из БД.

10 f
Как можно взаимодействовать между процессами?
Если вообще: файлы, очереди, shared_memory, pipes в multiprocessing, сокеты.
Если на практике: очереди сообщений, celery.

11 f
Что нужно сделать, чтобы написать таск на селери?
Создаём Celery-приложение (tasks.py). Определяем задачи с помощью декоратора @app.task. Запускаем worker для выполнения задач.
Отправляем задачи с помощью delay.
(Опционально) Настраиваем бэкенд для хранения результатов.
(Опционально) Настраиваем периодические задачи с помощью Celery Beat.
```
from celery.schedules import crontab
	
app.conf.beat_schedule = {
    'add-every-30-seconds': {
        'task': 'tasks.add',
        'schedule': 30.0,
        'args': (16, 16),  # Аргументы задачи
    },
    'run-every-monday-at-8am': {
        'task': 'tasks.another_task',
        'schedule': crontab(hour=8, minute=0, day_of_week=1),
    },
}
	
# celery -A tasks beat --loglevel=info
```

12 f
Из чего состоит celery?
* Клиент. Вызывает задачи с помощью delay (или apply_async).
* Брокер. Отвечает за передачу задач от клиента к воркерам
* Воркеры — это процессы, которые выполняют задачи из очереди. Они постоянно опрашивают брокер на наличие новых задач и выполняют их.
* Задачи (Tasks) — это функции, которые выполняются асинхронно. Они определяются с помощью декоратора @app.task.
* Бэкенд (Backend). Используется для хранения результатов выполнения задач. Это необязательный компонент, но он полезен, если нужно сохранять результаты для последующего использования.
* Планировщик (Celery Beat)
Также у нас есть:
* Цепочки задач (Chains): Последовательное выполнение задач.
* Группы задач (Groups): Параллельное выполнение задач.
* Хорды (Chords): Группы задач с финальным callback'ом.
* Retries: Повторное выполнение задач в случае ошибок.

13 f
Для чего используется селери?
Для запуска асинхронных задач, не прерывая основной поток выполнения. Также можно выполнять задачи по расписанию.



# algorithms 16

1 f
Что такое алгоритмическая сложность? Как ее определять?
Алгоритмическая сложность описывает скорость работы алгоритма. Критерий не время, а количество операций.
Для обозначения используется  О-большое

2 f
Что такое стек?
Структура данных в которую элементы добавляются по принципц LIFO (last in first out). Может использоваться для организации данных в памяти. Когда вызывается функция, аргументы добавляются в стек.

3 f
Что такое очередь?
Структура данных в которую элементы добавляются по принципу FIFO (first in first out).

4 f
Что такое дек?
Структура данных, которая представляет собой последовательность элементов, у которой есть два конца. 

5 f
Что такое куча?
Структура данных на основе двоичного дерева. Используется для эффективного управления и извлечения минимального или максимального элемента из коллекции элементов. Соответственно, есть min-куча, и max-куча.
В max-куче корневым всегдя является наибольший элемент и каждый из элементов кучи больше или равен любому из своих потомков. 
Обычно реализуется в виде массива. 

6 f
Что такое граф?
Нелинейная структура организации данных, которая состоит из «вершин» и «ребер» между ними. Бывают ориентированные и неориентированные графы.

7 f
Что такое дерево?
Иерархическая структура данных, состоящая из узлов и рёбер. Самый верхний узел — корень, от него отходят ветви. Узлы, из которых не выходят ветви, называются листьями. Узлы между корнем и листьями — внутренними узлами.

8 f
Что такое бинарное дерево?
Дерево, в котором каждый узел имеет не более двух дочерних элементов, называемых левым дочерним элементом и правым дочерним элементом.

9 f
Что такое односвязный список?
Структура данных, представляющая собой последовательность элементов, в каждом из которых хранится значение и указатель на следующий элемент списка.

10 f
Что такое двусвязный список?
Структура данных, представляющая собой последовательность элементов, в каждом из которых хранится значение и указатели на предыдущий и следующий элемент списка.

11 f
Какие ты знаешь алгоритмы сортировки? Какая у них сложность?	Пока ответа нет
Сортировка пузырьком. Заключается в постепенном смещении элементов с большим значением в конец массива. `O(n**2)`.
Быстрая сортировка. Считается одним из самых быстрых алгоритмов сортировки. `O(n log n)`. 
Сортировка слиянием. Следует принципу разделяй и властвуй, согласно которому массив данных разделяется на равные части, которые сортируются по отдельности. После они сливаются, в результате получается отсортированный массив. O(n log n).
Сортировка кучей. Алгоритм выстраивает данные в виде двоичного дерева (двоичной кучи). O(n log n).
Сортировка выбором. Алгоритм ищет наименьший элемент в текущем списке и производит обмен его значения со значением первой неотсортированной позиции. `О(n**2)`.
TODO: practice

12 f
Алгоритм бинарного поиска?
Выбирается средний элемент. Проверка, далее выбираем интервал справа или слева.

13 f
Расскажи какие ты знаешь способы обхода графа?
DFS. BFS. DFS использует стек, а BFS — очередь.  Сложность: O(V+E), где V — число вершин, а E — число рёбер.
Алгоритм Дейкстры - находит кратчайший путь от начального узла ко всем остальным узлам в графе.
Алгоритм A* - находит кратчайший путь от начального узла к конечному узлу (цели). Эффективнее. Использует эвристическую функцию.

14 f
Сложность поиска в бинарном дереве?
Средний случай: O(log n), если дерево сбалансировано.
Худший случай: O(n), если дерево вырождено в связный список.

15 f
Какую проблему решают красно-чёрные деревья?
Поддерживают свой баланс, когда в него добавляются/удаляются узлы. Приемлемая производительность операций поиска, вставки и удаления: O(nlogn).
Есть операции поворота/вращения (rotation) и перекрашивания (recoloring).

16 f
AVL-деревья?
Двоичное дерево поиска и поддерживают баланс. 


# soft_skills 5

1f
Что такое Jira?
Инструмент управления проектами. Планирование и систематизация задач, отслеживание работы. 

2 f
Что такое Confluence?
Используется для документации, структурировании информации. Создание единой базы знаний команды.

3 f
Что такое Kanban?
Kanban дает больше гибкости - возможна смена приоритетов. Вчера вы залили на прод новую фичу, а сегодня получили данные, что эта штука не работает так, как было задумано. Задача поднимается в очерди наверх, программист берет эту задачу, выполняет ее и, к вечеру fix уже на проде.

4 f
Что такое Scrum?
Основу Scrum составляют или спринты (2-3 недели). Перед началом спринта команда формирует список фич на итерацию.
После окончания спринта выполненные фичи заливаются на продакшн, а невыполненные — переносятся в другой спринт. Как правило, фичи, которые делаются во время спринта, не меняются: что было на старте спринта — должно быть сделано любой ценой к окончанию спринта.

5 f
Какая разница между Scrum и Kanban
Канбан более гибкий: сосредоточен больше на спринтах чем задачах.
Scrum и Kanban — представители методологий Agile-семейства. 
Agile характеризуется:
* Люди и взаимодействие важнее процессов и инструментов.
* Работающий продукт важнее исчерпывающей документации.
* Сотрудничество с заказчиком важнее согласования условий контракта.
* Готовность к изменениям важнее следования первоначальному плану.


# deploy 7

1 f
Что такое CI/CD? Какие в нём есть этапы?
CI (непрерывная интеграция) - процесс, который гарантирует получение протестированного, версионированного и готового к развертыванию на конкретной инфраструктуре куска или полной версии приложения. Как только продукт протестирован, можно говорить о внедрении CI в процесс разработки.
CD — доставка приложения до продуктивной среды - автоматизация всего процесса реплиза ПО. Continuous deployment — все изменения автоматически развёртываютс в продакшн без какого-либо ручного воздействия и дополнительных подтверждений. Continuous delivery — доставка «с кнопкой», здесь необходимо ручное вмешательство и сбор согласий.

2 f
Как обычно вручную деплоится бэкенд?
Ну, в ручную можно и через фтп-менеджер.
Сборка образов, отправка кода сервер: тесты, линтер. git, docker contexts. Перезагружаем nginx.
TODO: есть похожий вопрос?

3 f
В чем отличие облака и выделенного сервера для деплоя?
В облаке легче масштабировать приложение. Легко запусить новые мощности и отказаться о них, когда они не нужны.

4 f
Какая разница между CI и CD
Непрерывная интеграция (CI): сборка и тестирование.
Непрерывная доставка (CD): автоматизируется CI + весь процесс релиза ПО. Может состоять из нескольких этапов. Развертывание в продакшен выполняется вручную.
Непрерывное развертывание: CI + CD + полностью автоматизированное развертывание в продакшен.

5 f
Что такое mypy? Какие у него есть преимущества?
Инструмент для проверки типов. Обнаруживает ошибки связанные с типами.

6 f
Куда попадает собранный контейнер после сборки?
Физически сохраняется в корневом каталоге Docker (/var/lib/docker).
```
docker image ls # or docker images
docker image inspect <image_name>
```

7 f
Что такое kaniko?
Инструмент для создания образов контейнеров из Dockerfile. Можно собирать в кластере Kubernetes.



# architecture 42

1 f
В чём плюсы и минусы монолитного подхода?
Все компоненты приложения объединены в одну систему - более простая и понятная разработка.
Нет необходимости в API для связи компонентов.
Легче отладка и тестирование.
Экономичнее в создании и проще в поддержке.
Одна база данных - нет необходимости в механизмах синхронизации.
Высокая производительность.
Минусы:
Сложности масштабирования.
Больше уязвимость к сбоям.
Тяжело добавлять новые технологии.

2 f
В чём плюсы и минусы микросервисного подхода?
Масштабируемость. Каждый сервис отдельно.
Независимое развёртывание. Более простое обновление.
Более быстрое внедрение нового функционала.
Отказоустойчивость.
Минусы:
Скорость разработки первой версии.
Взаимодействие между сервисами. Дополнительный код, API, задержки.
Более сложное тестирование.
Затраты на инфраструктуру.

3 f
Что такое монолитное приложение? Когда оно становится монолитным?
Приложение состоящее из одной кодовой базы. Система работает как единое целое в рамках одного процесса. 

4 f
Что такое микросервисы?
Набор небольших автономных компонентов, которые можно разрабатывать, развёртывать независимо друг от друга.
Каждый микросервис отвечает за конкретную бизнес-задачу, имеет собственное хранилище данных и общается с другими сервисами через простые API-интерфейсы.

5 f
Что такое lambda-computing?
Это концепция вычислений, основанная на модели serverless, при которой код выполняется в ответ на события, а инфраструктура автоматически управляется и масштабируется облачным провайдером. Lambda-computing позволяет запускать функции (небольшие фрагменты кода) без необходимости вручную настраивать или поддерживать серверы, что даёт разработчикам гибкость и экономичность.	

6 f
Приведи пример порождающих, структурных и поведенческих паттернов?
Порождающие:
* Абстрактная фабрика
* Фабричный метод
* Синглтон
Структурные:
* Декоратор
* Фасад
* Заместитель
Поведенческие:
* Посетитель
* Наблюдатель
* Итератор
* Стратегия
TODO: hard

7 f
Расскажи про паттерн одиночка?
Применяется, когда необходим класс, у которого должен быть единственный экземпляр во всей программе.

8 f
Расскажи про паттерн стратегия?
Позволяет инкапсулировать набор взаимозаменяемых алгоритмов, из которых пользователь выбирает тот, что ему нужен.
TODO: practice

9 f
Расскажи про паттерн фабричный метод?
Применяется, когда мы хотим, чтобы подклассы выбирали, какой класс инстанциировать, когда запрашивается объект. Это полезно само по себе, но можно пойти дальше и использовать в случае, когда класс заранее неизвестен (например, зависит от информации, прочитанной из файла или введенных пользователем данных).
TODO: practice, hard

10 f
Какие паттерны проектирования приложений ты знаешь?
Структурные, поведенческие, порождающие.
Или
MVC, MVP, MVVM
TODO: hard

11 f
Какие принципы чистого кода ты знаешь?
DRY, KISS, YAGNI, SOLID.

12 f
Что такое Saga?
Бизнес-операция разбивается на несколько небольших независимых этапов. Реализуется через сообщения в брокере. В случае сбоя на любом шаге система запускает компенсирующую транзакцию. Добавляем различные cancel и rollback в код.
* Оркестрированная Saga — центральный оркестратор управляет всеми шагами транзакции, отправляя команды каждому из сервисов и получая их отклик.
* Хореографированная Saga — сервисы взаимодействуют напрямую друг с другом через события. В случае успеха или ошибки каждый сервис сам решает, как реагировать на полученное событие и как выполнять свои операции.
TODO: usecase

13 f
Что такое API Gateway и Reverse Proxy?
Шлюз, который служит посредником между пользователем и онлайн-сервисами, предоставляя единую точку входа и направляя запросы от клиентов туда, куда нужно.

14 f
Какие паттерны микросервисной архитектуры ты знаешь?
* Service Registry (реестр сервисов). Обнаружение сервисов в распределённой системе. Каждый микросервис регистрирует себя в центральном реестре. Когда одному сервису нужно взаимодействовать с другим, он обращается к реестру, чтобы узнать текущий адрес нужного сервиса. 
* API Gateway (API-шлюз). Действует как единая точка входа для всех клиентских запросов.
* Data Sharding (шардинг данных)
* Sidecar (вспомогательный сервис). Этот паттерн предполагает присоединение вспомогательного сервиса (sidecar) к основному микросервису для обеспечения дополнительной функциональности, такой как логирование, коммуникация с внешними сервисами.
TODO: hard

15 f
Что такое circuit breaker?
Когда один сервис начинает давать сбои, Circuit Breaker временно блокирует запросы к этому сервису, предотвращая перегрузку и позволяя системе восстановиться. Три состояния
* Closed (Замкнут): В нормальном состоянии Circuit Breaker пропускает запросы. Если возникают ошибки (например, сервис не отвечает), он начинает фиксировать их количество.
* Open (Открыт): Если количество ошибок превышает определённый порог за заданный период, Circuit Breaker "размыкается", блокируя дальнейшие запросы к этому сервису на некоторое время. В это время запросы сразу отклоняются или перенаправляются на резервный ресурс, не достигая неисправного сервиса.
* Half-Open (Полуоткрыт): После тайм-аута Circuit Breaker переходит в режим "полуоткрытого" состояния и отправляет несколько тестовых запросов к сервису. Если тестовые запросы успешны, он возвращается в "замкнутое" состояние, и сервис считается восстановленным. Если тестовые запросы продолжают завершаться с ошибками, Circuit Breaker снова переходит в "открытое" состояние.
TODO: usecase

16 f
Что такое DDD (Domain-Driven Design)?
Акцент на предметной области. Разделение программного продукта на домены. Есть сервис заказов. Домен - управление заказами.
Ключевые понятия:
* Заказ (Order): Сущность, представляющая собой совокупность товаров, покупателя и адреса доставки.
* Товар (Product): Сущность, представляющая товар с его характеристиками (цена, название).
* Позиция заказа (OrderItem): Ценностный объект, представляющий конкретный товар в заказе с его количеством.
* Покупатель (Customer): Сущность, представляющая пользователя магазина.
* Адрес доставки (Address): Ценностный объект, описывающий адрес доставки.
Сущности (Entities): имеют уникальные идентификаторы (id) и меняющееся состояние (например, Order и Customer).
Ценностные объекты (Value Objects): определяются своими атрибутами, а не идентичностью (Address, OrderItem).
Репозиторий служит для работы с сущностями (сохранение, получение). Это абстракция над уровнем хранения данных.
Сервис содержит бизнес-логику, которая не относится к конкретной сущности: создать заказ, завершить заказ.
TODO: hard


17 f
Что такое MVC?
Архитектурный паттерн, который предполагает деление приложения на три части: модель, вид, контроллер.
* Model (Модель): Управляет данными и бизнес-логикой приложения.
* View (Представление): Отвечает за отображение данных пользователю.
* Controller (Контроллер): Обрабатывает ввод пользователя, взаимодействует с моделью и определяет, какое представление отобразить.
Особенности:
* View и Model не взаимодействуют напрямую.
* Controller служит посредником между View и Model.
* Часто используется в веб-разработке (например, Django, Ruby on Rails).
Пример потока данных:
10. Пользователь отправляет запрос.
11. Controller обрабатывает запрос, взаимодействует с Model для получения данных.
12. Controller передает данные в View.
13. View отображает данные пользователю.

18 f
Расскажи про Serverless-архитектуру?	
В serverless-подходе облачный провайдер автоматически управляет инфраструктурой, масштабированием и распределением ресурсов.
Основные принципы Serverless-архитектуры:
* Функции как сервис (FaaS, Function as a Service):
- Пример: AWS Lambda, Google Cloud Functions, Azure Functions.
- Serverless-архитектура построена вокруг событий. Функции вызываются в ответ на различные триггеры, такие как HTTP-запросы, изменения в базе данных, загрузка файлов и т.д.
- Это позволяет создать системы, которые работают асинхронно и реагируют на определённые действия или изменения состояния.
* Оплата за фактическое использование.
Таким образом, Serverless можно использовать там, где приходится не слишком часто, но интенсивно обрабатывать большое количество запросов. В этом случае запускать несколько функций на 15 минут выгоднее, чем все время держать виртуальную машину или сервер.

19 f
Что такое lambda-функция?
Lambda-функция — это кусок кода, который выполняется без необходимости управлять серверной инфраструктурой. Он запускается в ответ на события: HTTP-запросы, изменения в БД, загрузка файлов.

20 f
Какие паттерны отказоустойчивости ты знаешь?
* Circuit breaker.
* Bulkhead («Переборка»). Позволяет изолировать элементы приложения в пулы. В результате в случае сбоя одного из них другие продолжат свою работу.
* Watchdog периодически опрашивает сервисы, убеждаясь в их работоспособности. Обнаружение и мониторинг неисправностей. Для этого используют инструменты мониторинга, проверки работоспособности и автоматические оповещения. 
* Deadline propagation - Идея паттерна в том, что клиент в запросе к серверу передаёт значение тайм-аута. Сервер в процессе обработки запроса регулярно проверяет: не истёк ли тайм-аут на клиенте. Если истёк, то можно завершать обработку запроса ошибкой.
* Burst limit - ограничение по кол-ву одновременно выполняемых запросов по фикс. кол-ву - не очень, потому что обрезается всё чуть больше заданного rps, хотя сервер мог бы обработать заданный rps + epsilon. Например, не более 100 запросов в секунду.
* Rate limit - Burst limit по стратегии - допускается превышение rps на небольшое число от заданного при условии последующего снижения их кол-ва. Например, не более 1000 запросов в 10 секунд. Хорошо сочетается с Burst limit по фикс. кол-ву, когда rps значительно превышает заданный. Например Rate limit на 1000 запросов в 10 секунд, но Burst limit на 200 запросов в секунду.
* Избыточность и репликация. Механизмы дублируют критически важные компоненты, ресурсы или данные в нескольких экземплярах или расположениях.
* Автоматическое восстановление и отработка отказа. В случае сбоя перенаправляют трафик или рабочую нагрузку на исправные компоненты или системы резервного копирования.
* Retry - повторение операции при возникновении временного сбоя.
* Идемпотентность - добавление специального ключа, благодаря которому при ретраях не дублируются действия
TODO: hard


21 f
Что такое Dependency Injection?
паттерн проектирования при котором зависимости (например, сервисы, репозитории, конфигурации) передаются в класс или функцию извне, а не создаются внутри них.
Легче тестировать код - подставляя заглушки.


22 f
Расскажи про идемпотентность? Что такое ключи идемпотентности? Что такое хранилище ключей идемпотентности?
Это свойство объекта или операции при повторном применении операции к объекту давать тот же результат, что и при первом.
Ключ идемпотентности — это уникальный идентификатор операции. Его можно самостоятельно генерировать и использовать, когда необходимо запретить повторное выполнение той же операции до её завершения. Например, чтобы не сделать двойную выплату или списание. (uuid)
Ключ создаётся на стороне клиента и отправляется на сервер вместе с запросом.
Хранилище ключей идемпотентности предоставляет механизм для отслеживания уникальных ключей и связанных с ними данных. Обычно ключи хранятся в Redis.
Также идемпотентность можно обеспечить: запросами HTTP, уникальными идентификаторами, уникальными индексами в БД,

23 f
Что такое Code Debt и как с ним быть
Осознанное компромиссное решение, когда создаётся быстрое, пусть и не идеальное техническое решение, за которое придется расплатиться позднее.
Основных стратегий три.
* Переписывают все с нуля.
* Делают постепенный рефакторинг.
* Смиряются с техдолгом.

24 f
Как микросервисы могут между собой общаться?
HTTP или HTTPS - RESTful API.
Очереди сообщений.
RPC (вызовы удалённых процедур). RPC позволяет сервисам вызывать методы или процедуры в удалённых сервисах, как если бы они были локальными.

25 f
Как понять, когда лучше выстраивать коммуникацию через брокер сообщений, а когда через REST?
REST подходит, когда:
* предпочтительнее прямое взаимодействие запрос-ответ; 
* Коммуникация 1 на 1;
* масштаб небольшой, как и количество взаимодействующих сервисов, рабочих нагрузок и объём передаваемых данных.
Брокеры сообщений полезны, когда:
* нужна и допускается асинхронная коммуникация
* необходима модель коммуникации «многие ко многим»

26 f
Через GET запрос можно передавать данные на сервер? Какая проблема будет?
Передача секретных данных в открытом виде. Сохранения данных в логах. Ограничение на размер запроса.

27 f
Когда не стоит использовать принцип DRY?
Если нужно быстро создать MVP для проверки какой-либо гипотезы или создать свой пет проект.

28 f
Какие есть способы инвалидации кэша?	
* Инвалидация кэша по времени. Данные в кэше считаются недействительными после наступления определенного времени. Кэш обновляется каждый час в 00 минут (например, в 12:00, 13:00 и т.д.). Если данные изменились в источнике, кэш вручную очищается до следующего запланированного обновления.
* По ключу. К каждому значению привязывается ключ. Ключ перестаёт быть валидным, когда оригинальные данные изменены.
* Write-through. При обновлении оригинальных данных, обновляется и кэш.
* TTL (Time-To-Live). Есть TTL значение. При запросе оно проверяется. После истечения этого срока запись автоматически удаляется из кэша. Данные кэшируются с TTL = 60 секунд. Через 60 секунд после записи данные удаляются из кэша, и при следующем запросе они будут загружены заново.
* Write-behind. Запись сначала в кэш, потом в основную память.

29 f
Расскажи про чистую архитектуру?	
Развивает идеи луковичной. Архитектура разделена на несколько слоев, каждый из которых отвечает за определенные аспекты системы:
- Сущности (Entities): Бизнес-объекты и правила.
- Сценарии использования (Use Cases): Операции, которые приложение выполняет для достижения бизнес-целей.
- Интерфейсные адаптеры (Interface Adapters): Преобразуют данные между внутренними слоями и внешними источниками (например, контроллеры, презентеры).
- Фреймворки и драйверы: Внешние инструменты и технологии (например, базы данных, UI-фреймворки).
Архитектура не зависит от конкретных технологий и фреймворков, что позволяет легко заменять их при необходимости.
Выполняются принципы SOLID:
Бизнес-логика полностью отделена от деталей реализации, таких как базы данных и внешние сервисы.
Взаимодействие между слоями происходит через четко определенные интерфейсы, что облегчает замену и обновление компонентов.
Плюсы Чистой архитектуры
- Слабая связность: Компоненты системы слабо связаны друг с другом, что облегчает их замену и модификацию без влияния на другие части системы.
* Легко тестировать.
* Гибкость и масштабируемость
* Независимость от фреймворков и технологий
Минусы Чистой архитектуры
- Более сложная структура: Разделение на слои и управление зависимостями добавляют уровень сложности, который может быть избыточен для небольших проектов.
- Больше кода и шаблонов. Необходимо писать дополнительные абстракции, интерфейсы и адаптеры, что увеличивает объем кода.
- Более длительное время разработки. Настройка архитектуры требует больше времени на начальных этапах разработки

30 f
Расскажи про паттерн наблюдатель (Observer)?	
Решает задачу автоматического уведомления заинтересованных объектов (наблюдателей) об изменениях в другом объекте (субъекте/издателе).
* У нас есть «издатель» (subject), который «изменяется».
* Есть «наблюдатели» (observers), которые хотят узнавать об изменениях издателя.
* Когда в издателе что-то меняется, он оповещает всех подписанных наблюдателей.
Пример:
Сервис оплаты — чтобы списать деньги.
Сервис доставки — чтобы начать подготовку и отгрузку товара.
При появлении нового заказа «издатель» (OrderManager) рассылает всем «наблюдателям» (PaymentService, ShippingService и т.д.) уведомление о событии.
```
class OrderManager:
"""Издатель (Subject) — оформляет заказ и рассылает уведомления."""
	def __init__(self):
		self.observers = []
	
	def attach(self, observer):
		self.observers.append(observer)
	
	def detach(self, observer):
		self.observers.remove(observer)
	
	def notify(self, order):
		for observer in self.observers:
			observer.update(order)
	
	def create_order(self, user_id, items):
		order = {"user_id": user_id, "items": items, "order_id": 123}
		print(f"Заказ")
		self.notify(order)
	
class PaymentService:
	def update(self, order):
		print(f"Оплата")

class ShippingService:
	def update(self, order):
	print(f"Доставка")
	
payment_service = PaymentService()
shipping_service = ShippingService()
order_manager = OrderManager()
order_manager.attach(payment_service)
order_manager.attach(notification_service)
order_manager.attach(shipping_service)
	
order_manager.create_order(user_id=42, items=["Laptop", "Mouse"])
```

31 f
Как глядя на сервис понять, он является монолитом или микросервисом?	
Сервис является монолитом, если он имеет более 15-20 эндпоинтов и/или нарушается принцип единой ответственности (S из SOLID), т.е. сервис отвечает более чем за одного актора.

32 f
Что такое модульный монолит?	
Архитектурный подход, при котором приложение по-прежнему развёртывается и функционирует как единое целое (монолит), но при этом внутри чётко разделен на модули с определёнными границами и интерфейсами.
Реализуется в Python за счёт разбиения проекта на файлы и независимые пакеты, использование Django Apps, Flask Blueprints, Fastapi Routers, инструментов Dependency Injection.

33 f
В чём минусы stateful?	
* Масштабируемость. Сложность горизонтального масштабирования. При добавлении новых узлов необходимо обеспечить синхронизацию состояния между ними.
* Уязвимость к сбоям: Если stateful сервис падает, его состояние может быть потеряно.
* Развертывание и обновление. Обновление stateful сервисов может требовать дополнительных шагов для сохранения и миграции состояния, что усложняет процесс развертывания и может привести к времени простоя.
* Управление состоянием. Управление состоянием усложняет логику приложения, так как необходимо учитывать сохранение, обновление и синхронизацию состояния. Хранение состояния требует дополнительной памяти и хранилища, что может увеличить затраты на инфраструктуру.
* Тестирование и отладка. Наличие состояния усложняет процесс тестирования и отладки, так как поведение сервиса может зависеть от его текущего состояния. Для проведения надежных тестов требуется управление состоянием, что увеличивает объем работы при написании тестов.

34 f
Чем отличается stateful от stateless?	
Stateful сервер хранит состояние клиента, а stateless нет.

35 f
Что такое слоистая, луковичная и гексогональная архитектруа?
Слоистая (трёхслойная) архитектура делит систему на несколько слоев (уровней).
* Presentation Layer (Уровень представления) - взаимодействие с пользователем.
* Business Logic Layer (Уровень бизнес-логики) - Содержит основную логику приложения.
* Data Access Layer (Уровень доступа к данным) - Отвечает за взаимодействие с базой данных или внешними источниками данных. Пример: запросы к базе данных, вызовы API.
Луковичная архитектура, строится вокруг доменного слоя (Domain Layer), который находится в центре. Внешние слои зависят от внутренних, но не наоборот. Это достигается за счет инверсии зависимостей (Dependency Inversion Principle).
* Domain Layer (Доменный слой). Содержит бизнес-логику и основные модели.
* Application Layer (Слой приложения): Содержит use cases (сценарии использования) и координирует работу доменного слоя.
* Infrastructure Layer (Инфраструктурный слой). Реализует технические детали, такие как доступ к базе данных, вызовы API и т.д.
* Presentation Layer (Слой представления). Отвечает за взаимодействие с пользователем.
Гексагональная архитектура, также известная как "Порты и адаптеры" (Ports and Adapters).
* Core (Ядро): Содержит бизнес-логику и доменные модели.
* Порты (Ports) — это интерфейсы, которые определяют, как приложение взаимодействует с внешним миром.
* Адаптеры (Adapters) — это реализации портов, которые связывают приложение с конкретными технологиями (например, базами данных, API).
TODO: доработать. Добавить сюда слоистую

36 f
Расскажи про паттерн unit of work?
Отслеживает все изменения, которые происходят с объектами в рамках одной бизнес-транзакции. Накапливает их и выполняет одним пакетом при завершении транзакции.
* Уменьшить количество обращений к базе данных.
* Обеспечить атомарность операций (все изменения либо применяются, либо откатываются).
* Упростить управление зависимостями между объектами.
Можно реализовать UoW в FastAPI как контекстный менеджер. Вначале принимает сессию к БД. В конце проверяет исключения.
TODO: example

37 f
Расскажи про паттерн Transactional Outbox?
Используется для обеспечения надежной доставки сообщений в распределенных системах, где важно гарантировать, что сообщения будут отправлены только после успешного завершения транзакции в базе данных.
Основная идея заключается в том, чтобы сохранить сообщение в той же транзакции, что и основное действие, а затем асинхронно отправить его.
В рамках одной транзакции с основным действием (например, изменение данных в базе) сообщение сохраняется в специальной таблице (Outbox) в той же базе данных.
Отдельный процесс (например, фоновый worker) периодически проверяет таблицу Outbox на наличие новых сообщений.
Если сообщение найдено, оно отправляется в брокер сообщений (например, Kafka, RabbitMQ).
После успешной отправки сообщение помечается как отправленное или удаляется из таблицы Outbox.
Пример: После успешного платежа нужно отправить событие в систему уведомлений для отправки чека пользователю. После регистрации нового пользователя нужно отправить событие.
Unit of Work инкапсулирует логику транзакций.
TODO: hard


38 f
По какому критерию выбираем что кэшировать?
Данные, которые запрашиваются часто, но редко изменяются, статичные данные. Данные, которые требуют значительных ресурсов для получения или вычисления. Данные, которые остаются актуальными в течение определенного времени. Данные, которые зависят от внешних систем с высокой задержкой или ограниченной пропускной способностью.

39 f
Фабрика и синглон разница.
Синглтон - единственный экземпляр класса.
Фабрика - создание объектов с общим интерфейсом

40 f
Два микросервиса. Продукты и заказы. Какую информацию из продуктов хранить в заказах, достаточно ли артикула?
Я бы сказал, что нет. Есть разные подходы.
Если храним только артикул, то мы зависимы от сервиса Продукты. И если он упадёт будут проблемы. Но данные всегда актуальны.
Если хранить дополнительные поля: цена, название, меньше зависимости, возможность сохранять историю. Но данные могут быть неактуальными.
Не стоит забывать про кэш.
* Появляется сервис цен. Сервис цен асинхронно по каждому продукту шлёт событие когда цена обновилась. Сервис с корзиной ждёт новые цены и сервис цен прислал два запроса одновременно. Какую цену ставить и как обеспечивать актуальную цену для корзины.
Хранить price_version или временную метку

41 f
В базе данных обновить все корзины по определённому продукту.
Используем Select for update. Очередность блокировки order by
TODO: usecase

42 f
Два сервиса ходят в рест. Один просит поменять тип данных или поле. В базе числа. Через несколько месяцев нужно перейти на строковые представления, что делать, чтобы не поломалось.
Создаём новую колонку со строкой. Обновляем обе колонки. Если данных много то добавление колонки будет мгновенным если поле nullable.
Добавляем в API ещё одно поле с другим типом или ещё один метод, в котором схема будет строковая. Через несколько месяцев перестаём использовать числа.



# logging 4

1 f
Зачем нужно делать логи в JSON формате?
Облегчить анализ и обработку. Удобно читать. JSON поддерживает разные типы данных - можно записывать подробную информацию.

2 f
Что такое event driven logging?
Логи записываются когда происходят ключевые события: исключения, пользовательские действия, системные события.

3 f
Какие ты знаешь уровни логирования?
DEBUG — отладочная информация (например, значения переменных).
INFO — общая информация о работе программы (например, запуск или завершение задачи).
WARNING — предупреждения о потенциальных проблемах.
ERROR — ошибки, которые не приводят к остановке программы.
CRITICAL — критические ошибки, которые могут привести к остановке программы.

# k8s 4

1 f
Что такое сервис?
Механизм для обеспечения доступа к набору подов в кластере. Сервисы создают эндпоинт для взаимодействия с приложениями.
Они решают задачи:
* Обнаружения подов. Сервис автоматически находит все поды, соответствующие определённым меткам (labels).
* Балансировки нагрузки.
* Предоставления стабильных конечных точек.
* Изоляция. Сервис может быть настроен для доступа только внутри кластера (ClusterIP) или извне (NodePort, ExternalName, LoadBalancer).

2 f
Что такое namespace?
Разделение ресурсов (поды, сервисы) в кластере на логические группы (для разработки, тестирования, продакшна).
```
kubectl create namespace development
	
kubectl get pods -n my-namespace
```

3 f
Что такое под?
Группа контейнеров, которые разделяют общие ресурсы: сеть, хранилище. Самая простая единица развёртывания в Kubernetes.  Поды используются для запуска приложений в кластере.

4 f
Как можно посмотреть логи подов?
```
kubectl logs <pod-name>
kubectl logs <pod-name> -c <container-name>
kubectl logs -f <pod-name> # следить за логами в реальном времени
kubectl logs <pod-name> --since=1h
```
Это позволяет получить доступ к выводу стандартного потока (stdout и stderr) контейнеров, работающих внутри пода.

# metrics 4

1 f
Что такое Sentry?
Мониторинг ошибок.
Если нужны продвинутые возможности визуализации данных и оповещения, то Grafana может быть предпочтительнее. Если нужны отслеживание ошибок и диагностика, то Sentry — лучше. 

2 f
Что такое Prometheus?	Пока ответа нет
Time-series база данных. Хранилище временных меток. Собирает метрики в приложении.

3 f
Что такое Grafana?	Пока ответа нет
Отображает метрики в дэшборде. Подключаешь как источник данных Prometheus.
Использует запросы на языке PromQL.

# django 27

1 f
Расскажи что такое Django? Из чего состоит?
Django is a high-level Python web framework celebrated for its emphasis on simplifying complex tasks and following the “Don’t Repeat Yourself” (DRY) and “model-template-views” (MTV) paradigms. It’s renowned for rapid development, robustness, and vast ecosystem of packages.

2 f
Что такое select_related? prefetch_related?
Используются для оптимизации запросов к базе данных. Помогают избежать проблемы N+1.
select_related выполняет JOIN. 1to1, 1toMany.
prefetch_related(): ManyToMany. Reverse ForeignKey. Отдельные запросы для каждой связи, а затем соединяет данные на уровне Python.
```
class Author(models.Model):
	...
	
class Book(models.Model):
    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='books')
    
books = Book.objects.select_related('author').all()
a = Author.objects.prefetch_related('books').all() # два запроса
```
TODO: practice

3 f
Что такое Middleware, для чего, как реализуется
Объект, который обрабатывает входящий запрос или исходящий ответ.
На уровне языка это объект с методами process_request и process_response. Методы должны вернуть принятый объект (запрос или ответ) для дальнейшей обработки или выкинуть исключение, если что-то не в порядке.
Чтобы включить Middleware, достаточно добавить путь к нему в список MIDDLEWARE.

4 f
Назовите основные мидлвари. Зачем они нужны
SessionMiddleware – поддержка сессий. Добавляет в запрос объект session
CsrfViewMiddleware – проверяет, что POST-запросы отправлены с текущего домена
AuthenticationMiddleware – авторизует пользователя. Добавляет в запрос поле user
MessageMiddleware – передает пользователю короткие сообщения

5 f
Опишите алгоритм работы CSRF middleware
На каждый запрос система генерирует уникальный токен и выставляет его в куках. В каждой форме размещается скрытое поле csrf-token с этим же токеном. При отправке формы методом POST Джанго проверяет, что поле формы и значение в куках совпадают. Если нет, это значит, что запрос подделан или отправлен с другого домена.

6 f
Что такое сигналы? Зачем нужны? Назовите основные
События в Джанго. С помощью сигналов подсистемы оповещают приложение о том, что случилось.
Важно: сигналы моделей работают поштучно, то есть для одной модели. При пакетной обработке, например, queryset.all().delete() или queryset.all().update({'foo'=42}), события об удалении или изменения не будут вызваны.
У нас была инвалидация кэша запросов, когда обновлялась статься.
```
from django.core.cache import cache
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from myapp.models import Product
	
@receiver([post_save, post_delete], sender=Product)
def invalidate_cache(sender, **kwargs):
    cache.delete('all_products')
```

7 f
Как реализуется связь m2m на уровне базы данных
Если есть модели A и B со связью многие ко многим, то создается таблица-мост с именем a_to_b, которая хранит ключ на A, ключ на B и дополнительные сведения, например, время, когда была создана связь. Эта таблица сцепляется с A и B оператором JOIN.

8 f
Чем лучше отправлять форму — GET или POST
Форму можно отправлять обоими способами. В первом случае переменные прикрепляются к строке запроса после вопросительного знака. Во втором – передаются в теле запроса.
Техническое ограничение метода GET в том, что им нельзя передать файл, в отличие от POST.
Форму желательно передавать методом POST по следующим причинам:
GET-запросы могут быть кешированы, особенно в браузерах семейства IE
GET-запросы оседают в логах провайдера, сервера, истории браузера. Пароль и логин в таком случае может засветиться во многих местах
некоторые вирусы отслеживают содержимое адресной строки и пересылают третьим лицам.

9 f
Как работает Serializer в Django REST Framework
Сериализатор DRF производит преобразование из моделей Django в JSON и наоборот.
```
class ThingSerializer(serializers.ModelSerializer):
  class Meta:
    model = Thing
    fields = (‘name’, )
```
fields указывает, какие поля доступны этому сериализатору. Можно использовать exclude вместо fields.

10 f
Что такое Meta в классах Django и для чего нужен
Задаёт параметры класса: указание таблицы базы данных, должна ли создаваться таблица, указание, что модель является абстрактной, unique_together, порядок сортировки по умолчани.

11 f
За что отвечает Meta в сериализаторе
Указывает модель для сериализатора. Настройка полей, которые будут включены (или exclude для исключения). Можно задать, например, специфическую валидацию списков.

12 f 
Как работает кэширование в джанго?
Используется встроенный фреймворк кэширования с поддержкой разных бэкэндов. У нас использовался Redis. Кэшировали отдельные вьюхи (декоратор `@cache_page(секунды)`) и фрагменты шаблонов (тэг `{% cache %}`, кэширование запросов к базе. 

13 f
Как в django работает система аутентификации
Мидлвэр django.contrib.auth, sessions. При аутентификации проверяем пароль, дальше логиним пользователя. После этого можем использовать декоратор @login.required на отдельных вьюхах или request.user.is_authenticated.

14 f
Объясни архитектурный шаблон MTV?
Model-View-Template. Почти же самое, что и MVC, но разные названия компонентов.
Model отвечает за данные и бизнес логику.
Template отвечает за отображение.
View отвечает за обработку запросов.

15 f 
Отличие проекта от приложения?
Проект включает настройки и может включать несколько приложений.
Приложение - это отдельный модуль с конкретной функциональностью.

16 f
Разница между ForeignKey и ManyToManyField?
```
class Author(models.Model):
    name = models.CharField(max_length=100)
	
class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.ForeignKey(Author, on_delete=models.CASCADE)
	
author = Author.objects.create(name="J.K. Rowling")
book = Book.objects.create(title="Harry Potter", author=author)
print(book.author.name)  # J.K. Rowling
	
class Student(models.Model):
    name = models.CharField(max_length=100)
	
class Course(models.Model):
    title = models.CharField(max_length=100)
    students = models.ManyToManyField(Student)
	
student1 = Student.objects.create(name="Alice")
student2 = Student.objects.create(name="Bob")
course = Course.objects.create(title="Math")
course.students.add(student1, student2)
print(course.students.all())  # Все студенты, записанные на курс
print(student1.course_set.all())  # Все курсы, на которые записан студент
```

17 f
Что такое QuerySet?
Представление набора запросов в Django.

18 f
От какого класса наследуюутся все модели?
```
from django.db import models
class Article(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    published_date = models.DateTimeField(auto_now_add=True)
    author = models.ForeignKey('Author', on_delete=models.CASCADE)
```

19 f
Как делать БД транзакции в Django?
django.db.transaction: transaction.atomic. Можно использовать как декоратор, и как контекстный менеджер. Можно использовать transaction (commit, rollback).

20 f
Разница между function-based view и class-based view?
function-based view - обычная функция.
class-based-view - класс. Обработка POST, GET, в разных методах. Есть готовые классы для распространённых задач: TemplateView, ListView, DetailView.

21 f
Декоратор @login_required
Если неавторизованный пользователь пытается получить доступ к представлению, он будет перенаправлен на страницу с логином.

22 f
Примеры ORM
```
author1 = Author.objects.create(name='Jane', email='j@e.com')
author3 = Author(name='Alice', email='alice@example.com')
author3.save()
article2.categories.add(category2)
authors = Author.objects.all()
author = Author.objects.get(pk=1)
articles = Article.objects.filter(author=author)
articles = Article.objects.filter(title__contains='AI')
articles = Article.objects.filter(publication_date__year=2023)
authors = Author.objects.exclude(email='jane.doe@example.com')
article = Article.objects.first()
author_count = Author.objects.count()
exists = Author.objects.filter(email='jane@example.com').exists()
	
# Использование Q-объектов для сложных запросов (комбинация AND и OR)
from django.db.models import Q
articles = Article.objects.filter(Q(author=author1) | Q(publication_date__year=2023))
	
Article.objects.filter(author=author).update(content='Updated content for all articles')
author.delete()
```

23 f
Защита веб-приложений
csrf-токены, @login_required, сессии, экранирование шаблонов {{my_htmlsafe}}, валидация форм.

24 f
Что делает декоратор @action?
Декоратор @action в DRF позволяет создавать кастомные методы в ViewSet, которые будут доступны как отдельные endpoint'ы. Позволяют расширить стандартный набор методов (таких как list, retrieve, create, update, partial_update, destroy) 
```
from rest_framework.decorators import action
from rest_framework.response import Response
	
class PostViewSet(viewsets.ModelViewSet):
    queryset = Post.objects.all()
    serializer_class = PostSerializer
	
    @action(detail=True, methods=['post'])
    def like(self, request, pk=None):
        post = self.get_object()
        post.likes += 1
        post.save()
        return Response({'likes': post.likes})
	
	@action(detail=False, methods=['get'])
	def stats(self, request):
	    total_posts = Post.objects.count()
	    total_likes = Post.objects.aggregate(total_likes=Sum('likes'))['total_likes']
	    return Response({'total_posts': total_posts, 'total_likes': total_likes})
```

25 f 
Для чего нужен annotate()?
Для выполнения агрегаций и добавления вычисляемых полей к каждому объекту в QuerySet.
```
from django.db.models import Count
from myapp.models import Author
	
# Добавляем поле num_books к каждому автору
authors = Author.objects.annotate(num_books=Count('book'))
for author in authors:
    print(f"{author.name} has {author.num_books} books")
	
SELECT author.id, author.name, COUNT(book.id) AS num_books
FROM author
LEFT JOIN book ON author.id = book.author_id
GROUP BY author.id, author.name;
```
aggregate() - Вычисляет общее значение для всего QuerySet.
```
stats = Author.objects.aggregate(total_authors=Count('id'), avg_books=Avg('book__rating'))
```
TODO: example. Мне кажется такой пример не будет работать.

26 f
Q() в Django
F() в Django
TODO: finish

27 f
Как эффективно добавить много записей в БД
bulk_create()
TODO: example

28 f
Вытащить миллионы записей:
Использовать итератор. Вытаскивает наборами. Исполняется лениво. По умолчанию 2000. Фильтрация и срезы должны идти до итератора. Использует курсоры БД.
```
for obj in LargeModel.objects.all().iterator():
```



# fastapi 28

1 f
На чём основан FastAPI
Starlette (использует anyio, который использует asyncio) для веб и pydantic для данных.
Starlette - asgi фреймворк.
anyio - для конкурентности.
Pydantic для типов. Инструмент проверки типов.

2 f
На чём основаны модели данных в FastAPI:
Все модели данных наследуют от pydantic.BaseModel

3 f
Документация в FastAPI?
FastAPI предоставляет автоматическую документацию SwaggerUI (/docs) и ReDoc (/redoc). Использует спецификации OpenAPI.

4 f
Как FastAPI сериализирует и проверяет данные на валидность? Какая роль pydantic в FastAPI?
В ендпойнте указываем какую Pydantic модель мы ожидаем. FastAPI автоматически проведёт валидацию и выдаст ошиббку, если данные не соответствуют.

5 f
Декоратор computed_field в Pydantic?
В поле хранится значение, которое вычисляется на основе других полей модели.
```
from pydantic import BaseModel, computed_field
class Product(BaseModel):
  name: str
  price: int
	
class Order(BaseModel):
  items: list[Product]
	
  @computed_field
  def total_price(self) -> int:
     return sum(item.price for item in self.items)
```


6 f
Как бы ты реализовал аутентификацию и авторизацию в FastAPI?
FastAPI предоставляет модуль безоспасности.
fastapi.security.OAuth2PasswordBearer. Используем функцию Depends для Dependency injection. Для авторизации используется security scopes. Каждый ендпоинт  может иметь список скоупов как зависимости. Когда приходит запрос, то проверяется имеет ли текущий пользователь нужный скоуп.
```
from fastapi import Depends, FastAPI, HTTPException, Security
from fastapi.security import OAuth2PasswordBearer, SecurityScopes
	
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
	
def get_current_user(security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme)):
    # decode token and fetch user data here
    raise HTTPException(status_code=403, detail="Not authenticated")
	
app = FastAPI()
	
@app.get("/items/", dependencies=[Depends(Security(get_current_user, scopes=["items:read"]))])
async def read_items():
    return [{"item": "Foo", "value": "Bar"}]
```
TODO: example

7 f
Как реализовать обработку исключений в FastAPI?
fastapi.exceptions.HTTPException.
```
from fastapi import FastAPI, HTTPException
	
app = FastAPI()
	
@app.exception_handler(HTTPException)
async def http_exception_handler(request, exc):
    return JSONResponse(
        status_code=exc.status_code,
        content={"message": f"Oops! {exc.detail}"},
    )
    
@app.get("/items/{item_id}")
async def read_item(item_id: str):
    if item_id not in items:
        raise HTTPException(status_code=404, detail="Item not found")
```


8 f
Как загружать файлы в FastAPI?
В ендпоинт передаём параметр с типом UploadFile.
```
from fastapi import FastAPI, UploadFile, File
app = FastAPI()
@app.post("/files/")
async def create_file(file: UploadFile = File(...)):
    return {"filename": file.filename}
```

9 f
Как Pydantic и Starlette используются в FastAPI?
Starlette используется для роутинга, а Pydantic для валидации и сериализации.

10 f
CORS (Cross-Origin Resource Sharing) в FastAPI?
Есть встроенное middleware:
```
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

11 f
Как FastAPI работает с куки и сессиями?
Использует Starlette’s SessionMiddleware.

12 f
Как возвращать статичные файлы через FastAPI?
Монтируем ендпоинт, который будет отдавать статичные файлы.
```
from fastapi import FastAPI
from starlette.staticfiles import StaticFiles
app = FastAPI()
app.mount("/static", StaticFiles(directory="static"), name="static")
```

13f
FOR UPDATE в SQLAlchemy?
```
from sqlalchemy import select
session = Session()
stmt = select(Account).where(Account.id == 1).with_for_update()
user = session.execute(stmt).scalar_one()
```

14 f
Как вернуть данные в JSON в FastAPI?
В ответе отдаём модель Pydantic.

15 f
Как в FastAPI принимать одновременно JSON и файлы?
Pydantic модель для данных в JSON для автоматической валидации запроса
Роут принимает File и форму.
```
from fastapi import FastAPI, File, Form, UploadFile
from pydantic import BaseModel
	
app = FastAPI()
	
class Item(BaseModel):
    name: str
    description: str
	
@app.post("/upload/")
async def upload_file(item: Item = Form(...), file: UploadFile = File(...)):
    return {"filename": file.filename, "item_name": item.name, "description": item.description}
```

16 f
Как в FastAPI инициализировать глобальный объект или переменную и использовать её во всех эндпоинтах?
Использовал бы синглтон.

17 f
Для чего используется APIRouter?
Организация маршрутов (endpoints).
```
from fastapi import APIRouter, HTTPException
	
router = APIRouter(prefix="/users", tags=["users"])
	
@router.get("/")
def get_users():
    return something
	
@router.get("/{user_id}")
def get_user(user_id: int):
	return something
	
router = APIRouter(prefix="/api")
router = APIRouter(tags=["users"]) # группировка роутов в доках
	
# зависимости для всех маршрутов в роуте
from fastapi import Depends
def common_parameters():
    return {"q": "some query"}
router = APIRouter(dependencies=[Depends(common_parameters)])
	
# общие ответы для всех маршрутов
from fastapi.responses import JSONResponse
router = APIRouter(responses={404: {"description": "Not found"}})
```

18 f
Транзакция в SQLAlchemy?
Транзакция начинается автоматически при первом обращении к базе данных через сессию. Сессия - объект, который управляет взаимодействием с базой данных.
```
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
	
# Создаем подключение к базе данных (SQLite в памяти)
engine = create_engine('sqlite:///:memory:', echo=True)
	
# Базовый класс для моделей
Base = declarative_base()
	
# Определяем модель User
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)
	
# Создаем таблицу
Base.metadata.create_all(engine)
	
# Создаем сессию
Session = sessionmaker(bind=engine)
session = Session()
	
# Начинаем транзакцию
try:
    # Добавляем нового пользователя
    new_user = User(name='Alice')
    session.add(new_user)
	
    # Выполняем еще одну операцию
    another_user = User(name='Bob')
    session.add(another_user)
	
    # Фиксируем транзакцию (сохраняем изменения)
    session.commit()
except Exception as e:
    # Если произошла ошибка, откатываем транзакцию
    session.rollback()
    print(f"Ошибка: {e}")
finally:
    # Закрываем сессию
    session.close()
```
SQLAlchemy также поддерживает использование контекстного менеджера для работы с транзакциями:
```
with session.begin():
    new_user = User(name='Charlie')
    session.add(new_user)
```

19 f
Как реализовать события ORM в SQLAlchemy?
События на уровне модели позволяют отслеживать изменения в объектах ORM, такие как создание, обновление, удаление.
```
from sqlalchemy import event
# Функция-обработчик для события "после вставки"
@event.listens_for(User, 'after_insert')
def after_insert_listener(mapper, connection, target):
    print(f"Создан новый пользователь: {target.name} (ID: {target.id})")
```
События на уровне сессии позволяют отслеживать изменения в сессии, такие как добавление, удаление, фиксация транзакции.
```
@event.listens_for(session, 'before_commit')
def before_commit_listener(session):
    print("Перед фиксацией транзакции:")
```
События на уровне запросов позволяют отслеживать выполнение запросов.
```
@event.listens_for(session, 'before_execute')
def before_execute_listener(conn, clauseelement, multiparams, params):
    print(f"Выполняется запрос: {clauseelement}")
# Выполняем запрос
user = session.query(User).filter_by(name='Bob').first()
```
События на уровне транзакций (Transaction Events)
```
@event.listens_for(session, 'after_rollback')
def after_rollback_listener(session):
    print("Транзакция откачена")
# Имитируем откат транзакции
try:
    new_user = User(name='Charlie')
    session.add(new_user)
    raise Exception("Ошибка")
except:
    session.rollback()
```
События на уровне подключения (Connection Events)
```
@event.listens_for(engine, 'connect')
def connect_listener(dbapi_connection, connection_record):
    print("Установлено подключение к базе данных")
# Создаем новое подключение
engine.connect()
```

20 f
Взаимодействие с базой синхронно и асинхронно
В синхронном режиме приложение отправляет запрос к БД и ждёт, пока БД выполнит запрос и вернёт результат.
```
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
	
# Создаем синхронное подключение к БД
engine = create_engine('postgresql://user:password@localhost/dbname')
Session = sessionmaker(bind=engine)
session = Session()
	
# Синхронный запрос
result = session.execute("SELECT * FROM users WHERE id = 1")
print(result.fetchone())
```
В асинхронном режиме приложение отправляет запрос к БД и продолжает выполнять другие задачи, не дожидаясь завершения запроса. Когда запрос выполнен, БД возвращает результат через callback, future или coroutine.
```
import asyncio
import asyncpg
	
async def fetch_data():
    # Создаем асинхронное подключение к БД
    conn = await asyncpg.connect('postgresql://user:password@localhost/dbname')
    
    # Асинхронный запрос
    result = await conn.fetch("SELECT * FROM users WHERE id = 1")
    print(result)
    
    # Закрываем подключение
    await conn.close()
	
# Запуск асинхронной функции
asyncio.run(fetch_data())
	
	
# Асинхронный пул соединений:
import asyncio
import asyncpg
	
async def fetch_data():
    # Создаем пул асинхронных подключений
    pool = await asyncpg.create_pool('postgresql://user:password@localhost/dbname')
	
    async with pool.acquire() as conn:
        # Асинхронный запрос
        result = await conn.fetch("SELECT * FROM users WHERE id = 1")
        print(result)
    
    # Закрываем пул
    await pool.close()
	
# Запуск асинхронной функции
asyncio.run(fetch_data())
	
	
#SQLAlchemy
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
	
# Асинхронный движок для подключения к PostgreSQL
DATABASE_URL = "postgresql+asyncpg://user:password@localhost/dbname"
	
# Создание асинхронного движка
engine = create_async_engine(DATABASE_URL, echo=True)
	
# Создание асинхронной сессии
AsyncSessionLocal = sessionmaker(
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False,
)
	
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
	
Base = declarative_base()
	
class Meme(Base):
    __tablename__ = "memes"
	
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True)
    description = Column(String)
	
	
from sqlalchemy.future import select
from sqlalchemy.ext.asyncio import AsyncSession
	
async def get_memes(db: AsyncSession, skip: int = 0, limit: int = 10):
    result = await db.execute(select(Meme).offset(skip).limit(limit))
    return result.scalars().all()
	
async def get_meme(db: AsyncSession, meme_id: int):
    result = await db.execute(select(Meme).filter(Meme.id == meme_id))
    return result.scalars().first()
	
async def create_meme(db: AsyncSession, meme: schemas.MemeCreate):
    db_meme = Meme(**meme.dict())
    db.add(db_meme)
    await db.commit()
    await db.refresh(db_meme)
    return db_meme
	
async def update_meme(db: AsyncSession, meme_id: int, meme: schemas.MemeCreate):
    result = await db.execute(select(Meme).filter(Meme.id == meme_id))
    db_meme = result.scalars().first()
    if db_meme:
        for key, value in meme.dict().items():
            setattr(db_meme, key, value)
        await db.commit()
        await db.refresh(db_meme)
    return db_meme
	
async def delete_meme(db: AsyncSession, meme_id: int):
    result = await db.execute(select(Meme).filter(Meme.id == meme_id))
    db_meme = result.scalars().first()
    if db_meme:
        await db.delete(db_meme)
        await db.commit()
    return db_meme
	
# Интеграция с FastAPI
from fastapi import FastAPI, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from . import models, schemas, crud
from .database import AsyncSessionLocal, engine
	
app = FastAPI()
	
# Зависимость для получения асинхронной сессии
async def get_db():
    async with AsyncSessionLocal() as db:
        yield db
	
@app.post("/memes/", response_model=schemas.Meme)
async def create_meme(meme: schemas.MemeCreate, db: AsyncSession = Depends(get_db)):
    return await crud.create_meme(db=db, meme=meme)
	
@app.get("/memes/", response_model=list[schemas.Meme])
async def read_memes(skip: int = 0, limit: int = 10, db: AsyncSession = Depends(get_db)):
    return await crud.get_memes(db, skip=skip, limit=limit)
	
@app.get("/memes/{meme_id}", response_model=schemas.Meme)
async def read_meme(meme_id: int, db: AsyncSession = Depends(get_db)):
    meme = await crud.get_meme(db, meme_id=meme_id)
    if meme is None:
        raise HTTPException(status_code=404, detail="Meme not found")
    return meme
```
Для работы с асинхронными миграциями используется alembic.

21 f
Почему ленивый подход не сработает при асинхронном запросе в БД
Асинхронные операции подразумевают, что результат запроса будет доступен не сразу. Ленивый подход предполагает, что вычисления или запросы будут выполнены только тогда, когда результат действительно понадобится.

22 f
Зачем использовать доменный клас User, вместо класса User от SQLAlchemy?
Разделяет ответственность между слоями приложения (чистая или слоистая архитектура).
Для преобразования можно использовать сериализацию.

23 f
Ленивая загрузка в SQLAlchemy?
Механизм, при котором связанные данные загружаются только при первом обращении к ним. Может привести к N+1 проблеме.
Ленивая загрузка требует активной сессии. Ошибка может произойти в шаблоне.
```
users = session.query(User).all()
for user in users:
    print(user.posts)  # Ленивая загрузка: выполняется отдельный запрос для каждого пользователя
	
from sqlalchemy.orm import joinedload
users = session.query(User).options(joinedload(User.posts)).all()
for user in users:
    print(user.posts)  # Все посты загружены одним запросом
```

24 f
Проблема SELECT+1 в SQLAlchemy?
joinedload - один к одному, один ко многим. Когда количество связных объектов не очень большое.
subqueryload - выполняет поздапрос.
selectinload - использует SELECT... IN ... Выполняет первый запрос, потом во второй запрос подставляет id первого.
```
authors = session.query(Author).options(joinedload(Author.books)).all()
	
authors = session.query(Author).options(selectinload(Author.books)).all()
	
authors = session.query(Author).options(subqueryload(Author.books)).all()
```

25 f
Как использовать пул соединений с БД в SQLAlchemy?
Подключаемся к pgBouncer:
```
# обычное подключение PostgreSQL (порт 5432)
# engine = create_engine("postgresql+psycopg2://user:password@host:5432/database")
	
# Подключение через pgBouncer (порт 6432)
engine = create_engine("postgresql+psycopg2://user:password@host:6432/database", pool_size = 10)
```

26 f
Воркеры в FastAPI?
Celery
BackgroundTasks - самый простой способ фоновых задач. Задачи выполняются на том же процессе, что и приложение.
```
from fastapi import FastAPI, BackgroundTasks
from time import sleep
	
app = FastAPI()
	
def write_log(message: str):
    sleep(5) # Simulate a long task
    with open("log.txt", "a") as f:
        f.write(f"{message}\n")
	
@app.get("/task")
def perform_task(background_tasks: BackgroundTasks, message: str):
    background_tasks.add_task(write_log, message)
    return {"message": "Task is in progress"}
```

27 f
SQLAlchemy flush?
Операция, которая отправляет все ожидающие изменения (pending changes) из сессии в базу данных. Не фиксирует транзакцию.
```
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base
	
engine = create_engine('sqlite:///:memory:')
Base = declarative_base()
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)
	
Base.metadata.create_all(engine)
	
Session = sessionmaker(bind=engine)
session = Session()
	
user = User(name="Alice")
session.add(user)
print(user.id) # None
session.flush()
print(user.id) # 1, SQLAlchemy сгенерировал ID
	
session.commit()
```
TODO: practice

28 f
Явный роллбэк для всех роутов, di и yield?
```
from fastapi import FastAPI, Depends, HTTPException, Request
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.ext.declarative import declarative_base
from typing import Generator
import asyncio
from contextlib import asynccontextmanager
	
engine = create_engine('sqlite:///:memory:')
Base = declarative_base()
	
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)
Base.metadata.create_all(engine)
	
SessionLocal = sessionmaker(bind=engine)
	
# Dependency to create and close a session for each request
@asynccontextmanager
async def get_db() -> Generator[Session, None, None]:
    session = SessionLocal()
    try:
      yield session
      session.commit()
    except Exception as e:
      print(f'Exception: {e}, Rolling back session')
      session.rollback()
      raise
    finally:
        session.close()
	
async def exception_handler(request: Request, exc: Exception):
    print(f'Exception was raised: {exc}')
    return HTTPException(status_code=500, detail='Internal server error')
	
app = FastAPI(exception_handlers={Exception: exception_handler})
	
@app.get("/users")
async def get_users(session: Session = Depends(get_db)):
  try:
    user = session.query(User).first()
    if user:
        user.name = 'Bob'
        # exception will occur here
        user.wrong_field # exception test
        session.commit()
    return {'user': user}
	
  except Exception as e:
    raise e # We are raising exception here to go into exception handler
```
TODO: practice

29 f
Функции path без async?
Будут запущены в external threadpool, вместо того, чтобы быть вызванными напрямую. То же самое и с зависимостями.
TODO: проверить



# Статистика 0

pass